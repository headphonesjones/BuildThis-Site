{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vega-lite.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/time-units.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compile/aggregate.js","src/compile/axis.js","src/compile/bin.js","src/compile/compile.js","src/compile/facet.js","src/compile/filter.js","src/compile/group.js","src/compile/layout.js","src/compile/legend.js","src/compile/marks.js","src/compile/scale.js","src/compile/sort.js","src/compile/stack.js","src/compile/style.js","src/compile/subfacet.js","src/compile/template.js","src/compile/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/lib/colorbrewer/colorbrewer.js","src/lib/d3-color/class.js","src/lib/d3-color/color.js","src/lib/d3-color/interpolate-lab.js","src/lib/d3-color/map.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","extend","Encoding","compile","data","field","enc","schema","toShorthand","shorthand","./Encoding","./compile/compile","./consts","./data","./enc","./field","./globals","./schema/schema","./util",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"bins","opt","step","level","minstep","precision","v","eps","maxb","maxbins","base","logb","Math","log","div","min","max","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","value","index","x","lo","hi","mid","cmp","this","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","spec","raw","../time-units","../util",5,"gen","repeat","val","Array","zeros","range","arguments","Infinity","j","random","uniform","undefined","d","samples","map","integer","b","normal","mean","stdev","next","rds","c","y","sqrt",6,"annotation","types","TYPES","type","values","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","keys","reduce","infer","TESTS","splice","inferAll","PARSERS","boolean","number","string","isNaN","Date","parse","all","parsers",7,"stats","unique","results","count","valid","missing","distinct","median","filter","sort","quantile","quartile","q","p","identity","H","h","sum","delta","variance","isArray","M2","modeskew","avg","med","std","extent","dot","Number","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","isFunction","L2","abs","m","R","M","entropy","counts","LN2","mutual","z","px","py","I","info","profile","sd","vals","q1","q3","summary","__summary__","./generate","./import/type",8,"STEPS","entries","format","UTC","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",9,"util_escape_str","replace","escape_str_re","strrep","str","truncateOnWord","rev","cnt","tok","split","truncate_word_re","reverse","w","join","trim","slice","Buffer","isNode","stderr","FNAME","namedfunc","duplicate","obj","JSON","stringify","equal","k","toMap","list","keystr","String","toString","Object","prototype","isObject","isBuffer","array","shift","apply","accessor","mutator","$func","op","$valid","$length","$year","$month","$date","$day","$hour","$minute","$in","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","startsWith","searchString","lastIndexOf","pad","pos","padchar","truncate","word","ellipsis","l1","l2","./time-units","_process","buffer",10,"vlfield","vlenc","theme","defaults","instantiate","specExtended","merge","_data","_marktype","marktype","_enc","encoding","_config","config","_filter","proto","fromShorthand","delim","assign","fromSpec","specFromShorthand","excludeConfig","toSpec","excludeData","subtract","is","has","encType","et","filterNull","forEach","fieldList","fieldName","Q","containsType","T","O","N","operands","operator","concat","nodata","nofn","fieldRef","_vega2","fieldTitle","isCount","displayName","timeUnit","aggregate","bin","toUpperCase","scale","axis","band","bandSize","useSmallBand","ROW","COL","size","MAXBINS_DEFAULT","legend","isTypes","toggleSort","support","qField","init","role","text","prop","TEXT","font","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","color","cardinality","isRaw","hasValues","transpose","oldenc","row","col","direction","mode","toggleFilterNullO","nulls",11,"aggregates","dataTable","dims","meas","detail","facets","transform","groupby","details","aggregated","../globals",12,"axis_title","def","layout","maxlength","cellWidth","cellHeight","setter","angle","align","baseline","dy","height","titleOffset","axisTitleOffset","axis_labels","time","hasScale","textTemplatePath","maxLabelLength","getter","names","props","defs","isCol","isRow","rowOffset","cellPadding","grid","layer","offset","stroke","opacity","x2","group","mult","orient","ticks","./time",13,"binning","output",14,"marks","facet","stack","style","subfacet","template","rawTable","addFilters","aggResult","sorting","mark","mdefs","mdef","lineType","line","hasDetails","from","by","legends","scales","properties","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./bin","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","./template","datalib/src/stats",15,"faceting","axesGrp","enter","facetKeys","cellAxes","hasRow","hasCol","fill","error","unshift","groupdef","width","trans",16,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","console","warn","test",17,"_name",18,"vllayout","box","hasX","hasY","xCardinality","yCardinality","padding","colCardinality","rowCardinality","getMaxLength","maxLength",19,"COLOR","SIZE","SHAPE","shape","labels",20,"bar_props","xc","y2","yc","ALPHA","point_props","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","fontWeight","fontStyle","bg","TABLE","bar","requiredEncoding","supportedEncoding","alpha","area","tick","circle","square","point",21,"scale_range","bandWidth","zero","nice","outerPadding","points","colorbrewer","interpolateLab","domain","STACKED","getDataset","ordinalPalette","palette","ps","interpolate","end","interpolator","../lib/colorbrewer/colorbrewer","../lib/d3-color/interpolate-lab",22,"addSortTransforms","datasetMapping","counter","byClause","dataName","transforms","source","RAW","../field",23,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",24,"estimateOpacity","numPoints","numMultiples",25,"subfaceting","g",26,"table","dataUrl","dataType","url",27,"timeFields","timeUnits","tf","fieldFn","func","stat","yearstat","formula","expr","labelLength","substr","isOrdinalFn","isColor",28,"encodingTypes","DETAIL",29,"vldata",30,"encTypes","countRetinal","fieldDef","arr","indexOf","enctype",31,"shorthands","timefns","tu","typeOrder","G","order","typeThenName","toLowerCase","original","typeThenCardinality","getbins","./compile/time",32,"INDEX",33,"YlGn","YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr","BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired","Pastel1","Pastel2","Set1","Set2","Set3",34,"ctor","key","defineProperty","enumerable",35,"d3_color","d3_hsl","d3_rgb_parse","d3_rgb_hsl","d3_hsl_rgb","m1","m2","vv","d3_rgb","d3_hcl","d3_lab","d3_lab_hcl","d3_rgb_lab","d3","rgb","d3_hcl_lab","cos","d3_radians","sin","atan2","d3_degrees","d3_lab_xyz","d3_xyz_lab","d3_xyz_rgb","d3_rgbNumber","d3_rgb_hex","hsl","exec","parseFloat","d3_rgb_parseNumber","d3_rgb_names","get","charAt","parseInt","d3_rgb_xyz","d3_lab_X","d3_lab_Y","d3_lab_Z","d3_hslPrototype","brighter","darker","hcl","d3_hclPrototype","d3_lab_K","lab","d3_labPrototype","d3_lab_rgb","lab_rgb","d3_rgbPrototype","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","set","./map",36,"al","bl","ba","./color",37,"d3_Map","_","create","d3_map_escape","d3_map_proto","d3_map_zero","d3_map_unescape","d3_map_has","d3_map_remove","d3_map_keys","d3_map_size","d3_map_empty","d3_class","object","remove","empty","./class",38,"enum","supportedEnums","supportedTypes","minimum","default","getSupportedRole","supportedRole","defaultTimeFn","scale_type","clone","typicalField","description","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","margin","weight","family","sizeMixin","colorMixin","alphaMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","formatType","additionalProperties","viewport","gridColor","gridOpacity","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","singleBarOffset","c10palette","c20palette","timeScaleLabelLength","characterWidth","$schema","./schemautil",39,"dest","src","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",40,"isin","item","thisArg","any","noaugment","msg","datalib/src/bins/bins","datalib/src/generate","datalib/src/util"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;\n},{\"./Encoding\":10,\"./compile/compile\":14,\"./consts\":28,\"./data\":29,\"./enc\":30,\"./field\":31,\"./globals\":32,\"./schema/schema\":38,\"./util\":40}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time-units\":8,\"../util\":9}],5:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],6:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":9}],7:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":5,\"./import/type\":6,\"./util\":9}],8:[function(require,module,exports){\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{}],9:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"./time-units\":8,\"_process\":3,\"buffer\":2}],10:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n    return vlfield.fieldRef(this._enc[et], {\n      nofn: nofn,\n      data: !this._vega2 && !nodata\n    });\n  };\n\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var timeUnit = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (timeUnit) {\n      return timeUnit.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.timeUnit = function(et) {\n    return this._enc[et].timeUnit;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = vlfield.isType;\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":28,\"./enc\":30,\"./field\":31,\"./globals\":32,\"./schema/schema\":38,\"./util\":40}],11:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":32,\"../util\":40}],12:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = 'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else {\n      setter(def, ['properties', 'grid'], {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var timeUnit;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (timeUnit = encoding.timeUnit(name)) && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, '{{data | number:\\'.3s\\'}}');\n  } else if (encoding.isType(name, T)) {\n    if (!encoding.timeUnit(name)) {\n      setter(def, textTemplatePath, '{{data | time:\\'%Y-%m-%d\\'}}');\n    } else if (encoding.timeUnit(name) === 'year') {\n      setter(def, textTemplatePath, '{{data | number:\\'d\\'}}');\n    }\n  } else if (encoding.isType(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n\n},{\"../globals\":32,\"../util\":40,\"./time\":27}],13:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.field(encType, false, /*nofn*/ true),\n        output: encoding.field(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n\n},{\"../globals\":32}],14:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compile.layout(encoding, stats),\n    spec = compile.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  dataTable = compile.bin(dataTable, encoding);     // modify dataTable\n  spec = compile.time(spec, encoding);              // modify dataTable, add scales\n  var aggResult = compile.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compile.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compile.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":10,\"../globals\":32,\"./aggregate\":11,\"./axis\":12,\"./bin\":13,\"./facet\":15,\"./filter\":16,\"./group\":17,\"./layout\":18,\"./legend\":19,\"./marks\":20,\"./scale\":21,\"./sort\":22,\"./stack\":23,\"./style\":24,\"./subfacet\":25,\"./template\":26,\"./time\":27,\"datalib/src/stats\":7}],15:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":32,\"../util\":40,\"./axis\":12,\"./group\":17,\"./scale\":21}],16:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n\n},{\"../globals\":32}],17:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter;\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggregate(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n\n},{\"../globals\":32,\"../util\":40}],19:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (timeUnit = encoding.timeUnit(name)) &&\n    time.hasScale(timeUnit)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n\n},{\"../globals\":32,\"./time\":27}],20:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.field(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.field(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.field(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: '{{' + e.field(TEXT) + ' | number:\\'.3s\\'}}'};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n\n},{\"../globals\":32}],21:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('../lib/colorbrewer/colorbrewer'),\n  interpolateLab = require('../lib/d3-color/interpolate-lab');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, stats, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.timeUnit(name);\n      return (timeUnit && time.scale.type(timeUnit, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.timeUnit(name), name);\n    if(range) return range;\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        fn: (opt.facet ? 'max_' : '') + 'sum'\n      })\n    };\n  }\n  return {data: sorting.getDataset(name), field: encoding.field(name)};\n};\n\n\nfunction scale_range(s, encoding, layout, stats, style, opt) {\n  // jshint unused:false\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.timeUnit(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.timeUnit(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.timeUnit(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.timeUnit(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\nscale.color = function(s, encoding, stats) {\n  var range = encoding.scale(COLOR).range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = encoding.config('ordinalPalette');\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = 'category10-k';\n        } else {\n          range = 'category20';\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n\n},{\"../globals\":32,\"../lib/colorbrewer/colorbrewer\":33,\"../lib/d3-color/interpolate-lab\":36,\"../util\":40,\"./time\":27}],22:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n\n},{\"../field\":31,\"../globals\":32}],23:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":32,\"./marks\":20}],24:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":31,\"../globals\":32}],25:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n\n},{\"../globals\":32,\"./group\":17}],26:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../field\":31,\"../globals\":32,\"./group\":17}],27:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    time.scale(scales, timeUnit, encoding);\n  }\n  return spec;\n}\n\n\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (timeUnit) {\n    case 'day':\n      scales.push({\n        name: 'time-'+timeUnit,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+timeUnit,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n\n},{\"../util\":40}],28:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":32}],29:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\n\n},{\"./globals\":32}],30:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n},{\"./consts\":28,\"./field\":31,\"./schema/schema\":38,\"./util\":40}],31:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  N: 0,\n  O: 1,\n  G: 2,\n  T: 3,\n  Q: 4\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggregate==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compile/time\":27,\"./consts\":28,\"./globals\":32,\"./schema/schema\":38,\"./util\":40}],32:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],33:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\nmodule.exports = {YlGn: {\n3: ['#f7fcb9','#addd8e','#31a354'],\n4: ['#ffffcc','#c2e699','#78c679','#238443'],\n5: ['#ffffcc','#c2e699','#78c679','#31a354','#006837'],\n6: ['#ffffcc','#d9f0a3','#addd8e','#78c679','#31a354','#006837'],\n7: ['#ffffcc','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#005a32'],\n8: ['#ffffe5','#f7fcb9','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#005a32'],\n9: ['#ffffe5','#f7fcb9','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#006837','#004529']\n},YlGnBu: {\n3: ['#edf8b1','#7fcdbb','#2c7fb8'],\n4: ['#ffffcc','#a1dab4','#41b6c4','#225ea8'],\n5: ['#ffffcc','#a1dab4','#41b6c4','#2c7fb8','#253494'],\n6: ['#ffffcc','#c7e9b4','#7fcdbb','#41b6c4','#2c7fb8','#253494'],\n7: ['#ffffcc','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#0c2c84'],\n8: ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#0c2c84'],\n9: ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#253494','#081d58']\n},GnBu: {\n3: ['#e0f3db','#a8ddb5','#43a2ca'],\n4: ['#f0f9e8','#bae4bc','#7bccc4','#2b8cbe'],\n5: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],\n6: ['#f0f9e8','#ccebc5','#a8ddb5','#7bccc4','#43a2ca','#0868ac'],\n7: ['#f0f9e8','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#08589e'],\n8: ['#f7fcf0','#e0f3db','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#08589e'],\n9: ['#f7fcf0','#e0f3db','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#0868ac','#084081']\n},BuGn: {\n3: ['#e5f5f9','#99d8c9','#2ca25f'],\n4: ['#edf8fb','#b2e2e2','#66c2a4','#238b45'],\n5: ['#edf8fb','#b2e2e2','#66c2a4','#2ca25f','#006d2c'],\n6: ['#edf8fb','#ccece6','#99d8c9','#66c2a4','#2ca25f','#006d2c'],\n7: ['#edf8fb','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#005824'],\n8: ['#f7fcfd','#e5f5f9','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#005824'],\n9: ['#f7fcfd','#e5f5f9','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#006d2c','#00441b']\n},PuBuGn: {\n3: ['#ece2f0','#a6bddb','#1c9099'],\n4: ['#f6eff7','#bdc9e1','#67a9cf','#02818a'],\n5: ['#f6eff7','#bdc9e1','#67a9cf','#1c9099','#016c59'],\n6: ['#f6eff7','#d0d1e6','#a6bddb','#67a9cf','#1c9099','#016c59'],\n7: ['#f6eff7','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016450'],\n8: ['#fff7fb','#ece2f0','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016450'],\n9: ['#fff7fb','#ece2f0','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016c59','#014636']\n},PuBu: {\n3: ['#ece7f2','#a6bddb','#2b8cbe'],\n4: ['#f1eef6','#bdc9e1','#74a9cf','#0570b0'],\n5: ['#f1eef6','#bdc9e1','#74a9cf','#2b8cbe','#045a8d'],\n6: ['#f1eef6','#d0d1e6','#a6bddb','#74a9cf','#2b8cbe','#045a8d'],\n7: ['#f1eef6','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#034e7b'],\n8: ['#fff7fb','#ece7f2','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#034e7b'],\n9: ['#fff7fb','#ece7f2','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#045a8d','#023858']\n},BuPu: {\n3: ['#e0ecf4','#9ebcda','#8856a7'],\n4: ['#edf8fb','#b3cde3','#8c96c6','#88419d'],\n5: ['#edf8fb','#b3cde3','#8c96c6','#8856a7','#810f7c'],\n6: ['#edf8fb','#bfd3e6','#9ebcda','#8c96c6','#8856a7','#810f7c'],\n7: ['#edf8fb','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#6e016b'],\n8: ['#f7fcfd','#e0ecf4','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#6e016b'],\n9: ['#f7fcfd','#e0ecf4','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#810f7c','#4d004b']\n},RdPu: {\n3: ['#fde0dd','#fa9fb5','#c51b8a'],\n4: ['#feebe2','#fbb4b9','#f768a1','#ae017e'],\n5: ['#feebe2','#fbb4b9','#f768a1','#c51b8a','#7a0177'],\n6: ['#feebe2','#fcc5c0','#fa9fb5','#f768a1','#c51b8a','#7a0177'],\n7: ['#feebe2','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177'],\n8: ['#fff7f3','#fde0dd','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177'],\n9: ['#fff7f3','#fde0dd','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177','#49006a']\n},PuRd: {\n3: ['#e7e1ef','#c994c7','#dd1c77'],\n4: ['#f1eef6','#d7b5d8','#df65b0','#ce1256'],\n5: ['#f1eef6','#d7b5d8','#df65b0','#dd1c77','#980043'],\n6: ['#f1eef6','#d4b9da','#c994c7','#df65b0','#dd1c77','#980043'],\n7: ['#f1eef6','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#91003f'],\n8: ['#f7f4f9','#e7e1ef','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#91003f'],\n9: ['#f7f4f9','#e7e1ef','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#980043','#67001f']\n},OrRd: {\n3: ['#fee8c8','#fdbb84','#e34a33'],\n4: ['#fef0d9','#fdcc8a','#fc8d59','#d7301f'],\n5: ['#fef0d9','#fdcc8a','#fc8d59','#e34a33','#b30000'],\n6: ['#fef0d9','#fdd49e','#fdbb84','#fc8d59','#e34a33','#b30000'],\n7: ['#fef0d9','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#990000'],\n8: ['#fff7ec','#fee8c8','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#990000'],\n9: ['#fff7ec','#fee8c8','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#b30000','#7f0000']\n},YlOrRd: {\n3: ['#ffeda0','#feb24c','#f03b20'],\n4: ['#ffffb2','#fecc5c','#fd8d3c','#e31a1c'],\n5: ['#ffffb2','#fecc5c','#fd8d3c','#f03b20','#bd0026'],\n6: ['#ffffb2','#fed976','#feb24c','#fd8d3c','#f03b20','#bd0026'],\n7: ['#ffffb2','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'],\n8: ['#ffffcc','#ffeda0','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'],\n9: ['#ffffcc','#ffeda0','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#bd0026','#800026']\n},YlOrBr: {\n3: ['#fff7bc','#fec44f','#d95f0e'],\n4: ['#ffffd4','#fed98e','#fe9929','#cc4c02'],\n5: ['#ffffd4','#fed98e','#fe9929','#d95f0e','#993404'],\n6: ['#ffffd4','#fee391','#fec44f','#fe9929','#d95f0e','#993404'],\n7: ['#ffffd4','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#8c2d04'],\n8: ['#ffffe5','#fff7bc','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#8c2d04'],\n9: ['#ffffe5','#fff7bc','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#993404','#662506']\n},Purples: {\n3: ['#efedf5','#bcbddc','#756bb1'],\n4: ['#f2f0f7','#cbc9e2','#9e9ac8','#6a51a3'],\n5: ['#f2f0f7','#cbc9e2','#9e9ac8','#756bb1','#54278f'],\n6: ['#f2f0f7','#dadaeb','#bcbddc','#9e9ac8','#756bb1','#54278f'],\n7: ['#f2f0f7','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#4a1486'],\n8: ['#fcfbfd','#efedf5','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#4a1486'],\n9: ['#fcfbfd','#efedf5','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#54278f','#3f007d']\n},Blues: {\n3: ['#deebf7','#9ecae1','#3182bd'],\n4: ['#eff3ff','#bdd7e7','#6baed6','#2171b5'],\n5: ['#eff3ff','#bdd7e7','#6baed6','#3182bd','#08519c'],\n6: ['#eff3ff','#c6dbef','#9ecae1','#6baed6','#3182bd','#08519c'],\n7: ['#eff3ff','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'],\n8: ['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'],\n9: ['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']\n},Greens: {\n3: ['#e5f5e0','#a1d99b','#31a354'],\n4: ['#edf8e9','#bae4b3','#74c476','#238b45'],\n5: ['#edf8e9','#bae4b3','#74c476','#31a354','#006d2c'],\n6: ['#edf8e9','#c7e9c0','#a1d99b','#74c476','#31a354','#006d2c'],\n7: ['#edf8e9','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#005a32'],\n8: ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#005a32'],\n9: ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#006d2c','#00441b']\n},Oranges: {\n3: ['#fee6ce','#fdae6b','#e6550d'],\n4: ['#feedde','#fdbe85','#fd8d3c','#d94701'],\n5: ['#feedde','#fdbe85','#fd8d3c','#e6550d','#a63603'],\n6: ['#feedde','#fdd0a2','#fdae6b','#fd8d3c','#e6550d','#a63603'],\n7: ['#feedde','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#8c2d04'],\n8: ['#fff5eb','#fee6ce','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#8c2d04'],\n9: ['#fff5eb','#fee6ce','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#a63603','#7f2704']\n},Reds: {\n3: ['#fee0d2','#fc9272','#de2d26'],\n4: ['#fee5d9','#fcae91','#fb6a4a','#cb181d'],\n5: ['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15'],\n6: ['#fee5d9','#fcbba1','#fc9272','#fb6a4a','#de2d26','#a50f15'],\n7: ['#fee5d9','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#99000d'],\n8: ['#fff5f0','#fee0d2','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#99000d'],\n9: ['#fff5f0','#fee0d2','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#a50f15','#67000d']\n},Greys: {\n3: ['#f0f0f0','#bdbdbd','#636363'],\n4: ['#f7f7f7','#cccccc','#969696','#525252'],\n5: ['#f7f7f7','#cccccc','#969696','#636363','#252525'],\n6: ['#f7f7f7','#d9d9d9','#bdbdbd','#969696','#636363','#252525'],\n7: ['#f7f7f7','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525'],\n8: ['#ffffff','#f0f0f0','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525'],\n9: ['#ffffff','#f0f0f0','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525','#000000']\n},PuOr: {\n3: ['#f1a340','#f7f7f7','#998ec3'],\n4: ['#e66101','#fdb863','#b2abd2','#5e3c99'],\n5: ['#e66101','#fdb863','#f7f7f7','#b2abd2','#5e3c99'],\n6: ['#b35806','#f1a340','#fee0b6','#d8daeb','#998ec3','#542788'],\n7: ['#b35806','#f1a340','#fee0b6','#f7f7f7','#d8daeb','#998ec3','#542788'],\n8: ['#b35806','#e08214','#fdb863','#fee0b6','#d8daeb','#b2abd2','#8073ac','#542788'],\n9: ['#b35806','#e08214','#fdb863','#fee0b6','#f7f7f7','#d8daeb','#b2abd2','#8073ac','#542788'],\n10: ['#7f3b08','#b35806','#e08214','#fdb863','#fee0b6','#d8daeb','#b2abd2','#8073ac','#542788','#2d004b'],\n11: ['#7f3b08','#b35806','#e08214','#fdb863','#fee0b6','#f7f7f7','#d8daeb','#b2abd2','#8073ac','#542788','#2d004b']\n},BrBG: {\n3: ['#d8b365','#f5f5f5','#5ab4ac'],\n4: ['#a6611a','#dfc27d','#80cdc1','#018571'],\n5: ['#a6611a','#dfc27d','#f5f5f5','#80cdc1','#018571'],\n6: ['#8c510a','#d8b365','#f6e8c3','#c7eae5','#5ab4ac','#01665e'],\n7: ['#8c510a','#d8b365','#f6e8c3','#f5f5f5','#c7eae5','#5ab4ac','#01665e'],\n8: ['#8c510a','#bf812d','#dfc27d','#f6e8c3','#c7eae5','#80cdc1','#35978f','#01665e'],\n9: ['#8c510a','#bf812d','#dfc27d','#f6e8c3','#f5f5f5','#c7eae5','#80cdc1','#35978f','#01665e'],\n10: ['#543005','#8c510a','#bf812d','#dfc27d','#f6e8c3','#c7eae5','#80cdc1','#35978f','#01665e','#003c30'],\n11: ['#543005','#8c510a','#bf812d','#dfc27d','#f6e8c3','#f5f5f5','#c7eae5','#80cdc1','#35978f','#01665e','#003c30']\n},PRGn: {\n3: ['#af8dc3','#f7f7f7','#7fbf7b'],\n4: ['#7b3294','#c2a5cf','#a6dba0','#008837'],\n5: ['#7b3294','#c2a5cf','#f7f7f7','#a6dba0','#008837'],\n6: ['#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837'],\n7: ['#762a83','#af8dc3','#e7d4e8','#f7f7f7','#d9f0d3','#7fbf7b','#1b7837'],\n8: ['#762a83','#9970ab','#c2a5cf','#e7d4e8','#d9f0d3','#a6dba0','#5aae61','#1b7837'],\n9: ['#762a83','#9970ab','#c2a5cf','#e7d4e8','#f7f7f7','#d9f0d3','#a6dba0','#5aae61','#1b7837'],\n10: ['#40004b','#762a83','#9970ab','#c2a5cf','#e7d4e8','#d9f0d3','#a6dba0','#5aae61','#1b7837','#00441b'],\n11: ['#40004b','#762a83','#9970ab','#c2a5cf','#e7d4e8','#f7f7f7','#d9f0d3','#a6dba0','#5aae61','#1b7837','#00441b']\n},PiYG: {\n3: ['#e9a3c9','#f7f7f7','#a1d76a'],\n4: ['#d01c8b','#f1b6da','#b8e186','#4dac26'],\n5: ['#d01c8b','#f1b6da','#f7f7f7','#b8e186','#4dac26'],\n6: ['#c51b7d','#e9a3c9','#fde0ef','#e6f5d0','#a1d76a','#4d9221'],\n7: ['#c51b7d','#e9a3c9','#fde0ef','#f7f7f7','#e6f5d0','#a1d76a','#4d9221'],\n8: ['#c51b7d','#de77ae','#f1b6da','#fde0ef','#e6f5d0','#b8e186','#7fbc41','#4d9221'],\n9: ['#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221'],\n10: ['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419'],\n11: ['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419']\n},RdBu: {\n3: ['#ef8a62','#f7f7f7','#67a9cf'],\n4: ['#ca0020','#f4a582','#92c5de','#0571b0'],\n5: ['#ca0020','#f4a582','#f7f7f7','#92c5de','#0571b0'],\n6: ['#b2182b','#ef8a62','#fddbc7','#d1e5f0','#67a9cf','#2166ac'],\n7: ['#b2182b','#ef8a62','#fddbc7','#f7f7f7','#d1e5f0','#67a9cf','#2166ac'],\n8: ['#b2182b','#d6604d','#f4a582','#fddbc7','#d1e5f0','#92c5de','#4393c3','#2166ac'],\n9: ['#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac'],\n10: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061'],\n11: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061']\n},RdGy: {\n3: ['#ef8a62','#ffffff','#999999'],\n4: ['#ca0020','#f4a582','#bababa','#404040'],\n5: ['#ca0020','#f4a582','#ffffff','#bababa','#404040'],\n6: ['#b2182b','#ef8a62','#fddbc7','#e0e0e0','#999999','#4d4d4d'],\n7: ['#b2182b','#ef8a62','#fddbc7','#ffffff','#e0e0e0','#999999','#4d4d4d'],\n8: ['#b2182b','#d6604d','#f4a582','#fddbc7','#e0e0e0','#bababa','#878787','#4d4d4d'],\n9: ['#b2182b','#d6604d','#f4a582','#fddbc7','#ffffff','#e0e0e0','#bababa','#878787','#4d4d4d'],\n10: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#e0e0e0','#bababa','#878787','#4d4d4d','#1a1a1a'],\n11: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#ffffff','#e0e0e0','#bababa','#878787','#4d4d4d','#1a1a1a']\n},RdYlBu: {\n3: ['#fc8d59','#ffffbf','#91bfdb'],\n4: ['#d7191c','#fdae61','#abd9e9','#2c7bb6'],\n5: ['#d7191c','#fdae61','#ffffbf','#abd9e9','#2c7bb6'],\n6: ['#d73027','#fc8d59','#fee090','#e0f3f8','#91bfdb','#4575b4'],\n7: ['#d73027','#fc8d59','#fee090','#ffffbf','#e0f3f8','#91bfdb','#4575b4'],\n8: ['#d73027','#f46d43','#fdae61','#fee090','#e0f3f8','#abd9e9','#74add1','#4575b4'],\n9: ['#d73027','#f46d43','#fdae61','#fee090','#ffffbf','#e0f3f8','#abd9e9','#74add1','#4575b4'],\n10: ['#a50026','#d73027','#f46d43','#fdae61','#fee090','#e0f3f8','#abd9e9','#74add1','#4575b4','#313695'],\n11: ['#a50026','#d73027','#f46d43','#fdae61','#fee090','#ffffbf','#e0f3f8','#abd9e9','#74add1','#4575b4','#313695']\n},Spectral: {\n3: ['#fc8d59','#ffffbf','#99d594'],\n4: ['#d7191c','#fdae61','#abdda4','#2b83ba'],\n5: ['#d7191c','#fdae61','#ffffbf','#abdda4','#2b83ba'],\n6: ['#d53e4f','#fc8d59','#fee08b','#e6f598','#99d594','#3288bd'],\n7: ['#d53e4f','#fc8d59','#fee08b','#ffffbf','#e6f598','#99d594','#3288bd'],\n8: ['#d53e4f','#f46d43','#fdae61','#fee08b','#e6f598','#abdda4','#66c2a5','#3288bd'],\n9: ['#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd'],\n10: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2'],\n11: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2']\n},RdYlGn: {\n3: ['#fc8d59','#ffffbf','#91cf60'],\n4: ['#d7191c','#fdae61','#a6d96a','#1a9641'],\n5: ['#d7191c','#fdae61','#ffffbf','#a6d96a','#1a9641'],\n6: ['#d73027','#fc8d59','#fee08b','#d9ef8b','#91cf60','#1a9850'],\n7: ['#d73027','#fc8d59','#fee08b','#ffffbf','#d9ef8b','#91cf60','#1a9850'],\n8: ['#d73027','#f46d43','#fdae61','#fee08b','#d9ef8b','#a6d96a','#66bd63','#1a9850'],\n9: ['#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850'],\n10: ['#a50026','#d73027','#f46d43','#fdae61','#fee08b','#d9ef8b','#a6d96a','#66bd63','#1a9850','#006837'],\n11: ['#a50026','#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850','#006837']\n},Accent: {\n3: ['#7fc97f','#beaed4','#fdc086'],\n4: ['#7fc97f','#beaed4','#fdc086','#ffff99'],\n5: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0'],\n6: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f'],\n7: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17'],\n8: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666']\n},Dark2: {\n3: ['#1b9e77','#d95f02','#7570b3'],\n4: ['#1b9e77','#d95f02','#7570b3','#e7298a'],\n5: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'],\n6: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02'],\n7: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d'],\n8: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666']\n},Paired: {\n3: ['#a6cee3','#1f78b4','#b2df8a'],\n4: ['#a6cee3','#1f78b4','#b2df8a','#33a02c'],\n5: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99'],\n6: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c'],\n7: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f'],\n8: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00'],\n9: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6'],\n10: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a'],\n11: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99'],\n12: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928']\n},Pastel1: {\n3: ['#fbb4ae','#b3cde3','#ccebc5'],\n4: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4'],\n5: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6'],\n6: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc'],\n7: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd'],\n8: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd','#fddaec'],\n9: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd','#fddaec','#f2f2f2']\n},Pastel2: {\n3: ['#b3e2cd','#fdcdac','#cbd5e8'],\n4: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4'],\n5: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9'],\n6: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae'],\n7: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae','#f1e2cc'],\n8: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae','#f1e2cc','#cccccc']\n},Set1: {\n3: ['#e41a1c','#377eb8','#4daf4a'],\n4: ['#e41a1c','#377eb8','#4daf4a','#984ea3'],\n5: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00'],\n6: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33'],\n7: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628'],\n8: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'],\n9: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999']\n},Set2: {\n3: ['#66c2a5','#fc8d62','#8da0cb'],\n4: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3'],\n5: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854'],\n6: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f'],\n7: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'],\n8: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494','#b3b3b3']\n},Set3: {\n3: ['#8dd3c7','#ffffb3','#bebada'],\n4: ['#8dd3c7','#ffffb3','#bebada','#fb8072'],\n5: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3'],\n6: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462'],\n7: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69'],\n8: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5'],\n9: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9'],\n10: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd'],\n11: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5'],\n12: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5','#ffed6f']\n}};\n},{}],34:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function d3_class(ctor, properties) {\n  for (var key in properties) {\n    Object.defineProperty(ctor.prototype, key, {\n      value: properties[key],\n      enumerable: false\n    });\n  }\n};\n},{}],35:[function(require,module,exports){\n'use strict';\n/* jshint ignore:start */\n\nvar d3 = module.exports = {\n  map: require('./map')\n};\n\nd3.color = d3_color;\n\nfunction d3_color() {}\nd3_color.prototype.toString = function() {\n  return this.rgb() + '';\n};\nd3.hsl = d3_hsl;\n\nfunction d3_hsl(h, s, l) {\n\n  return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length <\n    2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl,\n      d3_hsl) : new d3_hsl(h, s, l);\n}\nvar d3_hslPrototype = d3_hsl.prototype = new d3_color();\nd3_hslPrototype.brighter = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_hsl(this.h, this.s, this.l / k);\n};\nd3_hslPrototype.darker = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_hsl(this.h, this.s, k * this.l);\n};\nd3_hslPrototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1, m2;\n  h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n  s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n  return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nd3.hcl = d3_hcl;\n\nfunction d3_hcl(h, c, l) {\n  return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length <\n    2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l,\n      h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(\n      h, c, l);\n}\nvar d3_hclPrototype = d3_hcl.prototype = new d3_color();\nd3_hclPrototype.brighter = function(k) {\n  return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n};\nd3_hclPrototype.darker = function(k) {\n  return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n};\nd3_hclPrototype.rgb = function() {\n  return d3_hcl_lab(this.h, this.c, this.l).rgb();\n};\n\nfunction d3_hcl_lab(h, c, l) {\n  if (isNaN(h)) h = 0;\n  if (isNaN(c)) c = 0;\n  return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n}\nd3.lab = d3_lab;\n\nfunction d3_lab(l, a, b) {\n  return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length <\n    2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h,\n      l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n}\nvar d3_lab_K = 18;\nvar d3_lab_X = .95047,\n  d3_lab_Y = 1,\n  d3_lab_Z = 1.08883;\nvar d3_labPrototype = d3_lab.prototype = new d3_color();\nd3_labPrototype.brighter = function(k) {\n  return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this\n    .b);\n};\nd3_labPrototype.darker = function(k) {\n  return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n};\nd3_labPrototype.rgb = function() {\n  return d3_lab_rgb(this.l, this.a, this.b);\n};\n\nd3.lab_rgb = function d3_lab_rgb(l, a, b) {\n  var y = (l + 16) / 116,\n    x = y + a / 500,\n    z = y - b / 200;\n  x = d3_lab_xyz(x) * d3_lab_X;\n  y = d3_lab_xyz(y) * d3_lab_Y;\n  z = d3_lab_xyz(z) * d3_lab_Z;\n  return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 *\n    x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 *\n    z));\n}\n\nfunction d3_lab_hcl(l, a, b) {\n  return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(\n    NaN, NaN, l);\n}\n\nfunction d3_lab_xyz(x) {\n  return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n}\n\nfunction d3_xyz_lab(x) {\n  return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n}\n\nfunction d3_xyz_rgb(r) {\n  return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n}\nd3.rgb = d3_rgb;\n\nfunction d3_rgb(r, g, b) {\n  return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length <\n    2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb,\n      d3_hsl_rgb) : new d3_rgb(r, g, b);\n}\n\nfunction d3_rgbNumber(value) {\n  return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n}\n\nfunction d3_rgbString(value) {\n  return d3_rgbNumber(value) + \"\";\n}\nvar d3_rgbPrototype = d3_rgb.prototype = new d3_color();\nd3_rgbPrototype.brighter = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  var r = this.r,\n    g = this.g,\n    b = this.b,\n    i = 30;\n  if (!r && !g && !b) return new d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n};\nd3_rgbPrototype.darker = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_rgb(k * this.r, k * this.g, k * this.b);\n};\nd3_rgbPrototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\nd3_rgbPrototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0,\n    g = 0,\n    b = 0,\n    m1, m2, color;\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n      case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(\n            m2[2]));\n        }\n    }\n  }\n  if (color = d3_rgb_names.get(format.toLowerCase())) {\n    return rgb(color.r, color.g, color.b);\n  }\n  if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n    if (format.length === 4) {\n      r = (color & 3840) >> 4;\n      r = r >> 4 | r;\n      g = color & 240;\n      g = g >> 4 | g;\n      b = color & 15;\n      b = b << 4 | b;\n    } else if (format.length === 7) {\n      r = (color & 16711680) >> 16;\n      g = (color & 65280) >> 8;\n      b = color & 255;\n    }\n  }\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n    max = Math.max(r, g, b),\n    d = max - min,\n    h, s, l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    h = NaN;\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_lab(r, g, b) {\n  r = d3_rgb_xyz(r);\n  g = d3_rgb_xyz(g);\n  b = d3_rgb_xyz(b);\n  var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),\n    y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),\n    z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n  return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n}\n\nfunction d3_rgb_xyz(r) {\n  return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n}\n\nfunction d3_rgb_parseNumber(c) {\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\nvar d3_rgb_names = d3.map({\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n});\nd3_rgb_names.forEach(function(key, value) {\n  d3_rgb_names.set(key, d3_rgbNumber(value));\n});\n/* jshint ignore:end */\n\n},{\"./map\":37}],36:[function(require,module,exports){\n'use strict';\n\nvar d3 = require('./color');\n\nmodule.exports = function (a, b) {\n  a = d3.lab(a);\n  b = d3.lab(b);\n  var al = a.l,\n      aa = a.a,\n      ab = a.b,\n      bl = b.l - al,\n      ba = b.a - aa,\n      bb = b.b - ab;\n  return function(t) {\n    return d3.lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + '';\n  };\n};\n},{\"./color\":35}],37:[function(require,module,exports){\n'use strict';\n/* jshint ignore:start */\nvar d3_class = require('./class');\n\nmodule.exports = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n/* jshint ignore:end */\n},{\"./class\":34}],38:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('../lib/colorbrewer/colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        name: {\n          type: 'string'\n        },\n        aggregate: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n\n    // color\n    c10palette: {\n      type: 'string',\n      default: 'category10',\n      enum: [\n        // Tableau\n        'category10', 'category10k',\n        // Color Brewer\n        'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n      ]\n    },\n    c20palette: {\n      type: 'string',\n      default: 'category20',\n      enum: ['category20', 'category20b', 'category20c']\n    },\n    ordinalPalette: {\n      type: 'string',\n      default: 'BuGn',\n      enum: util.keys(colorbrewer)\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":32,\"../lib/colorbrewer/colorbrewer\":33,\"../util\":40,\"./schemautil\":39}],39:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":40}],40:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{\"datalib/src/bins/bins\":4,\"datalib/src/generate\":5,\"datalib/src/util\":9}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2JpbnMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZ2VuZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3R5cGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGltZS11bml0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy91dGlsLmpzIiwic3JjL0VuY29kaW5nLmpzIiwic3JjL2NvbXBpbGUvYWdncmVnYXRlLmpzIiwic3JjL2NvbXBpbGUvYXhpcy5qcyIsInNyYy9jb21waWxlL2Jpbi5qcyIsInNyYy9jb21waWxlL2NvbXBpbGUuanMiLCJzcmMvY29tcGlsZS9mYWNldC5qcyIsInNyYy9jb21waWxlL2ZpbHRlci5qcyIsInNyYy9jb21waWxlL2dyb3VwLmpzIiwic3JjL2NvbXBpbGUvbGF5b3V0LmpzIiwic3JjL2NvbXBpbGUvbGVnZW5kLmpzIiwic3JjL2NvbXBpbGUvbWFya3MuanMiLCJzcmMvY29tcGlsZS9zY2FsZS5qcyIsInNyYy9jb21waWxlL3NvcnQuanMiLCJzcmMvY29tcGlsZS9zdGFjay5qcyIsInNyYy9jb21waWxlL3N0eWxlLmpzIiwic3JjL2NvbXBpbGUvc3ViZmFjZXQuanMiLCJzcmMvY29tcGlsZS90ZW1wbGF0ZS5qcyIsInNyYy9jb21waWxlL3RpbWUuanMiLCJzcmMvY29uc3RzLmpzIiwic3JjL2RhdGEuanMiLCJzcmMvZW5jLmpzIiwic3JjL2ZpZWxkLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbGliL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwic3JjL2xpYi9kMy1jb2xvci9jbGFzcy5qcyIsInNyYy9saWIvZDMtY29sb3IvY29sb3IuanMiLCJzcmMvbGliL2QzLWNvbG9yL2ludGVycG9sYXRlLWxhYi5qcyIsInNyYy9saWIvZDMtY29sb3IvbWFwLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XG5cbnZhciB2bCA9IHt9O1xuXG51dGlsLmV4dGVuZCh2bCwgY29uc3RzLCB1dGlsKTtcblxudmwuRW5jb2RpbmcgPSByZXF1aXJlKCcuL0VuY29kaW5nJyk7XG52bC5jb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlL2NvbXBpbGUnKTtcbnZsLmRhdGEgPSByZXF1aXJlKCcuL2RhdGEnKTtcbnZsLmZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpO1xudmwuZW5jID0gcmVxdWlyZSgnLi9lbmMnKTtcbnZsLnNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xudmwudG9TaG9ydGhhbmQgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdmw7IixudWxsLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuLi90aW1lLXVuaXRzJyk7XG52YXIgRVBTSUxPTiA9IDFlLTE1O1xuXG5mdW5jdGlvbiBiaW5zKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIFRZUEVTID0gJ19fdHlwZXNfXyc7XG5cbnZhciBQQVJTRVJTID0ge1xuICBib29sZWFuOiB1dGlsLmJvb2xlYW4sXG4gIGludGVnZXI6IHV0aWwubnVtYmVyLFxuICBudW1iZXI6ICB1dGlsLm51bWJlcixcbiAgZGF0ZTogICAgdXRpbC5kYXRlLFxuICBzdHJpbmc6ICBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09JycgPyBudWxsIDogeDsgfVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09J3RydWUnIHx8IHg9PT0nZmFsc2UnIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbihkYXRhLCB0eXBlcykge1xuICBpZiAoIXR5cGVzKSByZXR1cm4gZGF0YSAmJiBkYXRhW1RZUEVTXSB8fCBudWxsO1xuICBkYXRhW1RZUEVTXSA9IHR5cGVzO1xufVxuXG5mdW5jdGlvbiB0eXBlKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbjtcblxuICAvLyBpZiBkYXRhIGFycmF5IGhhcyB0eXBlIGFubm90YXRpb25zLCB1c2UgdGhlbVxuICBpZiAodmFsdWVzW1RZUEVTXSkge1xuICAgIHYgPSBmKHZhbHVlc1tUWVBFU10pO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHYpKSByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7ICF1dGlsLmlzVmFsaWQodikgJiYgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiB1dGlsLmlzRGF0ZSh2KSA/ICdkYXRlJyA6XG4gICAgdXRpbC5pc051bWJlcih2KSAgICA/ICdudW1iZXInIDpcbiAgICB1dGlsLmlzQm9vbGVhbih2KSAgID8gJ2Jvb2xlYW4nIDpcbiAgICB1dGlsLmlzU3RyaW5nKHYpICAgID8gJ3N0cmluZycgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0eXBlQWxsKGRhdGEsIGZpZWxkcykge1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm47XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgcmV0dXJuICh0eXBlc1tmXSA9IHR5cGUoZGF0YSwgZiksIHR5cGVzKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBpbmZlcih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIGosIHY7XG5cbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3IsIGluIHByZWNlZGVuY2Ugb3JkZXJcbiAgdmFyIHR5cGVzID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgbmV4dCB2YWx1ZSB0byB0ZXN0XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgLy8gdGVzdCB2YWx1ZSBhZ2FpbnN0IHJlbWFpbmluZyB0eXBlc1xuICAgIGZvciAoaj0wOyBqPHR5cGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodXRpbC5pc1ZhbGlkKHYpICYmICFURVNUU1t0eXBlc1tqXV0odikpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBqIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vIHR5cGVzIGxlZnQsIHJldHVybiAnc3RyaW5nJ1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHJldHVybiAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiB0eXBlc1swXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgdmFyIHR5cGUgPSBpbmZlcihkYXRhLCBmKTtcbiAgICBpZiAoUEFSU0VSU1t0eXBlXSkgdHlwZXNbZl0gPSB0eXBlO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG50eXBlLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xudHlwZS5hbGwgPSB0eXBlQWxsO1xudHlwZS5pbmZlciA9IGluZmVyO1xudHlwZS5pbmZlckFsbCA9IGluZmVyQWxsO1xudHlwZS5wYXJzZXJzID0gUEFSU0VSUztcbm1vZHVsZS5leHBvcnRzID0gdHlwZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gZmlyc3Qtb2JzZXJ2ZWQgb3JkZXJcbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBmID0gdXRpbC4kKGYpO1xuICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICByZXN1bHRzLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgYXJyYXkuXG5zdGF0cy5jb3VudCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggfHwgMDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwsIG5vbi11bmRlZmluZWQsIG5vbi1OYU4gdmFsdWVzLlxuc3RhdHMuY291bnQudmFsaWQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIHZhbGlkID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB2YWxpZCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzLlxuc3RhdHMuY291bnQubWlzc2luZyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4vLyBOdWxsLCB1bmRlZmluZWQgYW5kIE5hTiBhcmUgZWFjaCBjb25zaWRlcmVkIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB1ID0ge30sIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGRpc3RpbmN0IHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLmNvdW50Lm1hcCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWFwID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgbWFwW3ZdID0gKHYgaW4gbWFwKSA/IG1hcFt2XSArIDEgOiAxO1xuICB9XG4gIHJldHVybiBtYXA7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHJldHVybiBzdGF0cy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgcXVhcnRpbGUgYm91bmRhcmllcyBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMucXVhcnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICB2YXIgcSA9IHN0YXRzLnF1YW50aWxlO1xuICByZXR1cm4gW3EodmFsdWVzLCAwLjI1KSwgcSh2YWx1ZXMsIDAuNTApLCBxKHZhbHVlcywgMC43NSldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgcXVhbnRpbGUgb2YgYSBzb3J0ZWQgYXJyYXkgb2YgbnVtYmVycy5cbi8vIEFkYXB0ZWQgZnJvbSB0aGUgRDMuanMgaW1wbGVtZW50YXRpb24uXG5zdGF0cy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcCkge1xuICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7IHAgPSBmOyBmID0gdXRpbC5pZGVudGl0eTsgfVxuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSxcbiAgICAgIGggPSBNYXRoLmZsb29yKEgpLFxuICAgICAgdiA9ICtmKHZhbHVlc1toIC0gMV0pLFxuICAgICAgZSA9IEggLSBoO1xuICByZXR1cm4gZSA/IHYgKyBlICogKGYodmFsdWVzW2hdKSAtIHYpIDogdjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3VtID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGZvciAodmFyIHN1bT0wLCBpPTAsIG49dmFsdWVzLmxlbmd0aCwgdjsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSBzdW0gKz0gdjtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgbiwgYywgdjtcbiAgZm9yIChpPTAsIGM9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGQpIHsgcmV0dXJuIHR5cGVvZiBkID09PSAnbnVtYmVyJzsgfVxuXG52YXIgZW50cmllcyA9IFtcbiAge1xuICAgIHR5cGU6ICdzZWNvbmQnLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kICVIOiVNOiVTLiVMJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDFlMyk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gKCtkIC8gMWUzKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnbWludXRlJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZICViICUtZCAlSDolTScsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiA2ZTQpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gNmU0KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnaG91cicsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQgJUg6MDAnLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogMzZlNSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyAzNmU1KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnZGF5JyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIHN0ZXA6IFsxLCA3XSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQnLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogODY0ZTUpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gODY0ZTUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdtb250aCcsXG4gICAgbWluc3RlcDogMSxcbiAgICBzdGVwOiBbMSwgMywgNl0sXG4gICAgZm9ybWF0OiAnJWIgJVknLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh+fihkIC8gMTIpLCBkICUgMTIsIDEpKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChpc051bWJlcihkKSkgZCA9IG5ldyBEYXRlKGQpO1xuICAgICAgcmV0dXJuIDEyICogZC5nZXRVVENGdWxsWWVhcigpICsgZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICd5ZWFyJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZCwgMCwgMSkpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gIH1cbl07XG5cbnZhciBtaW51dGVPZkhvdXIgPSB7XG4gIHR5cGU6ICdtaW51dGVPZkhvdXInLFxuICBtaW46IDAsXG4gIG1heDogNTksXG4gIG1pbnN0ZXA6IDEsXG4gIGZvcm1hdDogJyVNJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENNaW51dGVzKCk7XG4gIH1cbn07XG5cbnZhciBob3VyT2ZEYXkgPSB7XG4gIHR5cGU6ICdob3VyT2ZEYXknLFxuICBtaW46IDAsXG4gIG1heDogMjMsXG4gIG1pbnN0ZXA6IDEsXG4gIGZvcm1hdDogJyVIJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENIb3VycygpO1xuICB9XG59O1xuXG52YXIgZGF5T2ZXZWVrID0ge1xuICB0eXBlOiAnZGF5T2ZXZWVrJyxcbiAgbWluOiAwLFxuICBtYXg6IDYsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiAnJWEnLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQgKyBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENEYXkoKTtcbiAgfVxufTtcblxudmFyIGRheU9mTW9udGggPSB7XG4gIHR5cGU6ICdkYXlPZk1vbnRoJyxcbiAgbWluOiAxLFxuICBtYXg6IDMxLFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogJyUtZCcsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRGF0ZSgpO1xuICB9XG59O1xuXG52YXIgbW9udGhPZlllYXIgPSB7XG4gIHR5cGU6ICdtb250aE9mWWVhcicsXG4gIG1pbjogMCxcbiAgbWF4OiAxMSxcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6ICclYicsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENNb250aCgpO1xuICB9XG59O1xuXG52YXIgdW5pdHMgPSB7XG4gICdzZWNvbmQnOiAgICAgICBlbnRyaWVzWzBdLFxuICAnbWludXRlJzogICAgICAgZW50cmllc1sxXSxcbiAgJ2hvdXInOiAgICAgICAgIGVudHJpZXNbMl0sXG4gICdkYXknOiAgICAgICAgICBlbnRyaWVzWzNdLFxuICAnbW9udGgnOiAgICAgICAgZW50cmllc1s0XSxcbiAgJ3llYXInOiAgICAgICAgIGVudHJpZXNbNV0sXG4gICdtaW51dGVPZkhvdXInOiBtaW51dGVPZkhvdXIsXG4gICdob3VyT2ZEYXknOiAgICBob3VyT2ZEYXksXG4gICdkYXlPZldlZWsnOiAgICBkYXlPZldlZWssXG4gICdkYXlPZk1vbnRoJzogICBkYXlPZk1vbnRoLFxuICAnbW9udGhPZlllYXInOiAgbW9udGhPZlllYXIsXG4gICd0aW1lc3RlcHMnOiAgICBlbnRyaWVzXG59O1xuXG51bml0cy5maW5kID0gZnVuY3Rpb24oc3BhbiwgbWluYiwgbWF4Yikge1xuICB2YXIgaSwgbGVuLCBiaW5zLCBzdGVwID0gU1RFUFNbMF07XG5cbiAgZm9yIChpID0gMSwgbGVuID0gU1RFUFMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBzdGVwID0gU1RFUFNbaV07XG4gICAgaWYgKHNwYW4gPiBzdGVwWzBdKSB7XG4gICAgICBiaW5zID0gc3BhbiAvIHN0ZXBbMF07XG4gICAgICBpZiAoYmlucyA+IG1heGIpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbU1RFUFNbaSAtIDFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbc3RlcFsxXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnRyaWVzW1NURVBTW1NURVBTLmxlbmd0aCAtIDFdWzFdXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pdHM7XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHVuaXRzID0gcmVxdWlyZSgnLi90aW1lLXVuaXRzJyk7XG52YXIgdSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIHdoZXJlIGFyZSB3ZT9cblxudS5pc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgdHlwZW9mIHByb2Nlc3Muc3RkZXJyICE9PSAndW5kZWZpbmVkJztcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgIU51bWJlci5pc05hTihvYmopO1xufTtcblxudS5pc0J1ZmZlciA9IChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKSB8fCB1LmZhbHNlO1xuXG4vLyB0eXBlIGNvZXJjaW9uIGZ1bmN0aW9uc1xuXG51Lm51bWJlciA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiArcztcbn07XG5cbnUuYm9vbGVhbiA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBzPT09J2ZhbHNlJyA/IGZhbHNlIDogISFzO1xufTtcblxudS5kYXRlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IERhdGUucGFyc2Uocyk7XG59O1xuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107XG59O1xuXG51LnN0ciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHUuaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKHUuc3RyKSArICddJ1xuICAgIDogdS5pc09iamVjdCh4KSA/IEpTT04uc3RyaW5naWZ5KHgpXG4gICAgOiB1LmlzU3RyaW5nKHgpID8gKCdcXCcnK3V0aWxfZXNjYXBlX3N0cih4KSsnXFwnJykgOiB4O1xufTtcblxudmFyIGVzY2FwZV9zdHJfcmUgPSAvKF58W15cXFxcXSknL2c7XG5cbmZ1bmN0aW9uIHV0aWxfZXNjYXBlX3N0cih4KSB7XG4gIHJldHVybiB4LnJlcGxhY2UoZXNjYXBlX3N0cl9yZSwgJyQxXFxcXFxcJycpO1xufVxuXG4vLyBkYXRhIGFjY2VzcyBmdW5jdGlvbnNcblxudS5maWVsZCA9IGZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIFN0cmluZyhmKS5zcGxpdCgnXFxcXC4nKVxuICAgIC5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zcGxpdCgnLicpOyB9KVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoKSB7IGFbYS5sZW5ndGgtMV0gKz0gJy4nICsgYi5zaGlmdCgpOyB9XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYik7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBbXSk7XG59O1xuXG51LmFjY2Vzc29yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIGY9PW51bGwgfHwgdS5pc0Z1bmN0aW9uKGYpID8gZiA6XG4gICAgdS5uYW1lZGZ1bmMoZiwgKHMgPSB1LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHMucmVkdWNlKGZ1bmN0aW9uKHgsZikgeyByZXR1cm4geFtmXTsgfSwgeCk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfVxuICAgICk7XG59O1xuXG51LiQgPSB1LmFjY2Vzc29yO1xuXG51Lm11dGF0b3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gdS5pc1N0cmluZyhmKSAmJiAocz11LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICBmdW5jdGlvbih4LCB2KSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGgtMTsgKytpKSB4ID0geFtzW2ldXTtcbiAgICAgIHhbc1tpXV0gPSB2O1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKHgsIHYpIHsgeFtmXSA9IHY7IH07XG59O1xuXG51LiRmdW5jID0gZnVuY3Rpb24obmFtZSwgb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICBmID0gdS4kKGYpIHx8IHUuaWRlbnRpdHk7XG4gICAgdmFyIG4gPSBuYW1lICsgKHUubmFtZShmKSA/ICdfJyt1Lm5hbWUoZikgOiAnJyk7XG4gICAgcmV0dXJuIHUubmFtZWRmdW5jKG4sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG9wKGYoZCkpOyB9KTtcbiAgfTtcbn07XG5cbnUuJHZhbGlkICA9IHUuJGZ1bmMoJ3ZhbGlkJywgdS5pc1ZhbGlkKTtcbnUuJGxlbmd0aCA9IHUuJGZ1bmMoJ2xlbmd0aCcsIHUubGVuZ3RoKTtcbnUuJHllYXIgICA9IHUuJGZ1bmMoJ3llYXInLCB1bml0cy55ZWFyLnVuaXQpO1xudS4kbW9udGggID0gdS4kZnVuYygnbW9udGgnLCB1bml0cy5tb250aE9mWWVhci51bml0KTtcbnUuJGRhdGUgICA9IHUuJGZ1bmMoJ2RhdGUnLCB1bml0cy5kYXlPZk1vbnRoLnVuaXQpO1xudS4kZGF5ICAgID0gdS4kZnVuYygnZGF5JywgdW5pdHMuZGF5T2ZXZWVrLnVuaXQpO1xudS4kaG91ciAgID0gdS4kZnVuYygnaG91cicsIHVuaXRzLmhvdXJPZkRheS51bml0KTtcbnUuJG1pbnV0ZSA9IHUuJGZ1bmMoJ21pbnV0ZScsIHVuaXRzLm1pbnV0ZU9mSG91ci51bml0KTtcblxudS4kaW4gPSBmdW5jdGlvbihmLCB2YWx1ZXMpIHtcbiAgZiA9IHUuJChmKTtcbiAgdmFyIG1hcCA9IHUuaXNBcnJheSh2YWx1ZXMpID8gdS50b01hcCh2YWx1ZXMpIDogdmFsdWVzO1xuICByZXR1cm4gZnVuY3Rpb24oZCkgeyByZXR1cm4gISFtYXBbZihkKV07IH07XG59O1xuXG4vLyBjb21wYXJpc29uIC8gc29ydGluZyBmdW5jdGlvbnNcblxudS5jb21wYXJhdG9yID0gZnVuY3Rpb24oc29ydCkge1xuICB2YXIgc2lnbiA9IFtdO1xuICBpZiAoc29ydCA9PT0gdW5kZWZpbmVkKSBzb3J0ID0gW107XG4gIHNvcnQgPSB1LmFycmF5KHNvcnQpLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHMgPSAxO1xuICAgIGlmICAgICAgKGZbMF0gPT09ICctJykgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gJysnKSB7IHMgPSArMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBzaWduLnB1c2gocyk7XG4gICAgcmV0dXJuIHUuYWNjZXNzb3IoZik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGksIG4sIGYsIHgsIHk7XG4gICAgZm9yIChpPTAsIG49c29ydC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBmID0gc29ydFtpXTsgeCA9IGYoYSk7IHkgPSBmKGIpO1xuICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTEgKiBzaWduW2ldO1xuICAgICAgaWYgKHggPiB5KSByZXR1cm4gc2lnbltpXTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59O1xuXG51LmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYSA+PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn07XG5cbnUubnVtY21wID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbnUuc3RhYmxlc29ydCA9IGZ1bmN0aW9uKGFycmF5LCBzb3J0QnksIGtleUZuKSB7XG4gIHZhciBpbmRpY2VzID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGlkeCwgdiwgaSkge1xuICAgIHJldHVybiAoaWR4W2tleUZuKHYpXSA9IGksIGlkeCk7XG4gIH0sIHt9KTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgc2EgPSBzb3J0QnkoYSksXG4gICAgICAgIHNiID0gc29ydEJ5KGIpO1xuICAgIHJldHVybiBzYSA8IHNiID8gLTEgOiBzYSA+IHNiID8gMVxuICAgICAgICAgOiAoaW5kaWNlc1trZXlGbihhKV0gLSBpbmRpY2VzW2tleUZuKGIpXSk7XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cblxuLy8gc3RyaW5nIGZ1bmN0aW9uc1xuXG4vLyBFUzYgY29tcGF0aWJpbGl0eSBwZXIgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGgjUG9seWZpbGxcbi8vIFdlIGNvdWxkIGhhdmUgdXNlZCB0aGUgcG9seWZpbGwgY29kZSwgYnV0IGxldHMgd2FpdCB1bnRpbCBFUzYgYmVjb21lcyBhIHN0YW5kYXJkIGZpcnN0XG51LnN0YXJ0c1dpdGggPSBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggP1xuICBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xuICB9IDpcbiAgZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHNlYXJjaFN0cmluZywgMCkgPT09IDA7XG4gIH07XG5cbnUucGFkID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHBhZGNoYXIpIHtcbiAgcGFkY2hhciA9IHBhZGNoYXIgfHwgXCIgXCI7XG4gIHZhciBkID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIGlmIChkIDw9IDApIHJldHVybiBzO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHN0cnJlcChkLCBwYWRjaGFyKSArIHM7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHN0cnJlcChNYXRoLmZsb29yKGQvMiksIHBhZGNoYXIpICtcbiAgICAgICAgIHMgKyBzdHJyZXAoTWF0aC5jZWlsKGQvMiksIHBhZGNoYXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcyArIHN0cnJlcChkLCBwYWRjaGFyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RycmVwKG4sIHN0cikge1xuICB2YXIgcyA9IFwiXCIsIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG51LnRydW5jYXRlID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHdvcmQsIGVsbGlwc2lzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBsZW5ndGgpIHJldHVybiBzO1xuICBlbGxpcHNpcyA9IGVsbGlwc2lzICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZWxsaXBzaXMpIDogJ1xcdTIwMjYnO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgK1xuICAgICAgICBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKCcnKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHRydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHZsZW5jID0gcmVxdWlyZSgnLi9lbmMnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFbmNvZGluZyhzcGVjLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpLFxuICAgICAgc3BlY0V4dGVuZGVkID0gc2NoZW1hLnV0aWwubWVyZ2UoZGVmYXVsdHMsIHRoZW1lIHx8IHt9LCBzcGVjKSA7XG5cbiAgICB0aGlzLl9kYXRhID0gc3BlY0V4dGVuZGVkLmRhdGE7XG4gICAgdGhpcy5fbWFya3R5cGUgPSBzcGVjRXh0ZW5kZWQubWFya3R5cGU7XG4gICAgdGhpcy5fZW5jID0gc3BlY0V4dGVuZGVkLmVuY29kaW5nO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgICAvLyB0aGlzLl92ZWdhMiA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJvdG8gPSBFbmNvZGluZy5wcm90b3R5cGU7XG5cbiAgRW5jb2RpbmcuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCB0aGVtZSkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgICAgICAgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSksXG4gICAgICAgIG1hcmt0eXBlID0gc3BsaXQuc2hpZnQoKS5zcGxpdChjLmFzc2lnbilbMV0udHJpbSgpLFxuICAgICAgICBlbmMgPSB2bGVuYy5mcm9tU2hvcnRoYW5kKHNwbGl0KTtcblxuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1hcmt0eXBlOiBtYXJrdHlwZSxcbiAgICAgIGVuY29kaW5nOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogW11cbiAgICB9LCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYywgdGhlbWUpO1xuICB9O1xuXG4gIHByb3RvLnRvU2hvcnRoYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHRoaXMuX21hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyBzcGVjLm1hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZywgZXhjbHVkZURhdGEpIHtcbiAgICB2YXIgZW5jID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fZW5jKSxcbiAgICAgIHNwZWM7XG5cbiAgICBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IHRoaXMuX21hcmt0eXBlLFxuICAgICAgZW5jb2Rpbmc6IGVuYyxcbiAgICAgIGZpbHRlcjogdGhpcy5fZmlsdGVyXG4gICAgfTtcblxuICAgIGlmICghZXhjbHVkZUNvbmZpZykge1xuICAgICAgc3BlYy5jb25maWcgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9jb25maWcpO1xuICAgIH1cblxuICAgIGlmICghZXhjbHVkZURhdGEpIHtcbiAgICAgIHNwZWMuZGF0YSA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2RhdGEpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuICAgIHJldHVybiBzY2hlbWEudXRpbC5zdWJ0cmFjdChzcGVjLCBkZWZhdWx0cyk7XG4gIH07XG5cblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmVuYyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuTiAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW05dKSkge1xuICAgICAgICBmaWx0ZXJOdWxsLnB1c2goe1xuICAgICAgICAgIG9wZXJhbmRzOiBbZmllbGROYW1lXSxcbiAgICAgICAgICBvcGVyYXRvcjogJ25vdE51bGwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlck51bGwuY29uY2F0KHRoaXMuX2ZpbHRlcik7XG4gIH07XG5cbiAgLy8gZ2V0IFwiZmllbGRcIiBwcm9wZXJ0eSBmb3IgdmVnYVxuICBwcm90by5maWVsZCA9IGZ1bmN0aW9uKGV0LCBub2RhdGEsIG5vZm4pIHtcbiAgICBpZiAoIXRoaXMuaGFzKGV0KSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHZsZmllbGQuZmllbGRSZWYodGhpcy5fZW5jW2V0XSwge1xuICAgICAgbm9mbjogbm9mbixcbiAgICAgIGRhdGE6ICF0aGlzLl92ZWdhMiAmJiAhbm9kYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRSZWYgPSBmdW5jdGlvbihldCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIG9wdC5kYXRhID0gIXRoaXMuX3ZlZ2EyICYmIChvcHQuZGF0YSAhPT0gZmFsc2UpO1xuICAgIHJldHVybiB2bGZpZWxkLmZpZWxkUmVmKHRoaXMuX2VuY1tldF0sIG9wdCk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciB0aW1lVW5pdCA9IHRoaXMuX2VuY1tldF0uYWdncmVnYXRlIHx8IHRoaXMuX2VuY1tldF0udGltZVVuaXQgfHwgKHRoaXMuX2VuY1tldF0uYmluICYmICdiaW4nKTtcbiAgICBpZiAodGltZVVuaXQpIHtcbiAgICAgIHJldHVybiB0aW1lVW5pdC50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5iYW5kIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5iYW5kKGVuY1R5cGUpLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdncmVnYXRlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5hZ2dyZWdhdGU7XG4gIH07XG5cbiAgLy8gcmV0dXJucyBmYWxzZSBpZiBiaW5uaW5nIGlzIGRpc2FibGVkLCBvdGhlcndpc2UgYW4gb2JqZWN0IHdpdGggYmlubmluZyBwcm9wZXJ0aWVzXG4gIHByb3RvLmJpbiA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgdmFyIGJpbiA9IHRoaXMuX2VuY1tldF0uYmluO1xuICAgIGlmIChiaW4gPT09IHt9KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW4gPT09IHRydWUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXhiaW5zOiBzY2hlbWEuTUFYQklOU19ERUZBVUxUXG4gICAgICB9O1xuICAgIHJldHVybiBiaW47XG4gIH07XG5cbiAgcHJvdG8ubGVnZW5kID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5sZWdlbmQ7XG4gIH07XG5cbiAgcHJvdG8udmFsdWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLnZhbHVlO1xuICB9O1xuXG4gIHByb3RvLnRpbWVVbml0ID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS50aW1lVW5pdDtcbiAgfTtcblxuICBwcm90by5zb3J0ID0gZnVuY3Rpb24oZXQsIHN0YXRzKSB7XG4gICAgdmFyIHNvcnQgPSB0aGlzLl9lbmNbZXRdLnNvcnQsXG4gICAgICBlbmMgPSB0aGlzLl9lbmMsXG4gICAgICBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzO1xuXG4gICAgaWYgKCghc29ydCB8fCBzb3J0Lmxlbmd0aD09PTApICYmXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jOnRoaXMuX2VuY30sIHN0YXRzLCB0cnVlKSAmJiAvL0hBQ0tcbiAgICAgICAgdGhpcy5jb25maWcoJ3RvZ2dsZVNvcnQnKSA9PT0gUVxuICAgICAgKSB7XG4gICAgICB2YXIgcUZpZWxkID0gaXNUeXBlcyhlbmMueCwgW04sIE9dKSA/IGVuYy55IDogZW5jLng7XG5cbiAgICAgIGlmIChpc1R5cGVzKGVuY1tldF0sIFtOLCBPXSkpIHtcbiAgICAgICAgc29ydCA9IFt7XG4gICAgICAgICAgbmFtZTogcUZpZWxkLm5hbWUsXG4gICAgICAgICAgYWdncmVnYXRlOiBxRmllbGQuYWdncmVnYXRlLFxuICAgICAgICAgIHR5cGU6IHFGaWVsZC50eXBlLFxuICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnQ7XG4gIH07XG5cbiAgcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwua2V5cyh0aGlzLl9lbmMpLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsZW5jLm1hcCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXQpIHtcbiAgICByZXR1cm4gdmxlbmMucmVkdWNlKHRoaXMuX2VuYywgZiwgaW5pdCk7XG4gIH07XG5cbiAgcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMuZm9yRWFjaCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnR5cGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB0aGlzLl9lbmNbZXRdLnR5cGUgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLnJvbGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB2bGZpZWxkLnJvbGUodGhpcy5fZW5jW2V0XSkgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLnRleHQgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdmFyIHRleHQgPSB0aGlzLl9lbmNbVEVYVF0udGV4dDtcbiAgICByZXR1cm4gcHJvcCA/IHRleHRbcHJvcF0gOiB0ZXh0O1xuICB9O1xuXG4gIHByb3RvLmZvbnQgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLl9lbmNbVEVYVF0uZm9udDtcbiAgICByZXR1cm4gcHJvcCA/IGZvbnRbcHJvcF0gOiBmb250O1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZSA9IGZ1bmN0aW9uKGV0LCB0eXBlKSB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5lbmMoZXQpO1xuICAgIHJldHVybiBmaWVsZCAmJiBFbmNvZGluZy5pc1R5cGUoZmllbGQsIHR5cGUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzVHlwZSA9IHZsZmllbGQuaXNUeXBlO1xuXG4gIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc09yZGluYWxTY2FsZShlbmNvZGluZy5lbmMoZW5jVHlwZSkpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc0RpbWVuc2lvbihlbmNvZGluZy5lbmMoZW5jVHlwZSkpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNNZWFzdXJlKGVuY29kaW5nLmVuYyhlbmNUeXBlKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc0RpbWVuc2lvbih0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzTWVhc3VyZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZSh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgfTtcblxuICBFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbiA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSByYXcgT3hRIHdpdGggIyBvZiByb3dzID0gIyBvZiBPXG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzU3RhY2sgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAoc3BlYy5tYXJrdHlwZSA9PT0gJ2JhcicgfHwgc3BlYy5tYXJrdHlwZSA9PT0gJ2FyZWEnKSAmJlxuICAgICAgc3BlYy5lbmNvZGluZy5jb2xvcjtcbiAgfTtcblxuICBwcm90by5pc1N0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAodGhpcy5pcygnYmFyJykgfHwgdGhpcy5pcygnYXJlYScpKSAmJiB0aGlzLmhhcygnY29sb3InKTtcbiAgfTtcblxuICBwcm90by5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHN0YXRzKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuY2FyZGluYWxpdHkodGhpcy5lbmMoZW5jVHlwZSksIHN0YXRzLCB0aGlzLmNvbmZpZygnZmlsdGVyTnVsbCcpKTtcbiAgfTtcblxuICBwcm90by5pc1JhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0FnZ3JlZ2F0ZSgpO1xuICB9O1xuXG4gIHByb3RvLmRhdGEgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gIH07XG5cbiAgIC8vIHJldHVybnMgd2hldGhlciB0aGUgZW5jb2RpbmcgaGFzIHZhbHVlcyBlbWJlZGRlZFxuICBwcm90by5oYXNWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFscyA9IHRoaXMuZGF0YSgndmFsdWVzJyk7XG4gICAgcmV0dXJuIHZhbHMgJiYgdmFscy5sZW5ndGg7XG4gIH07XG5cbiAgcHJvdG8uY29uZmlnID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWdbbmFtZV07XG4gIH07XG5cbiAgRW5jb2RpbmcudHJhbnNwb3NlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHZhciBvbGRlbmMgPSBzcGVjLmVuY29kaW5nLFxuICAgICAgZW5jID0gdXRpbC5kdXBsaWNhdGUoc3BlYy5lbmNvZGluZyk7XG4gICAgZW5jLnggPSBvbGRlbmMueTtcbiAgICBlbmMueSA9IG9sZGVuYy54O1xuICAgIGVuYy5yb3cgPSBvbGRlbmMuY29sO1xuICAgIGVuYy5jb2wgPSBvbGRlbmMucm93O1xuICAgIHNwZWMuZW5jb2RpbmcgPSBlbmM7XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgLy8gRklYTUU6IFJFTU9WRSBldmVyeXRoaW5nIGJlbG93IGhlcmVcblxuICBFbmNvZGluZy50b2dnbGVTb3J0ID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcudG9nZ2xlU29ydCA9IHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQgPT09IFEgPyBOIDogUTtcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuZGlyZWN0aW9uID0gZnVuY3Rpb24oc3BlYykge1xuICAgIGlmICghRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHNwZWMpKSB7IHJldHVybjsgfVxuICAgIHZhciBlbmMgPSBzcGVjLmVuY29kaW5nO1xuICAgIHJldHVybiBlbmMueC50eXBlID09PSBOID8gJ3gnIDogJ3knO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQubW9kZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlYy5jb25maWcudG9nZ2xlU29ydDtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQgPSBmdW5jdGlvbihzcGVjLCBzdGF0cykge1xuICAgIHZhciBlbmMgPSBzcGVjLmVuY29kaW5nLFxuICAgICAgaXNUeXBlcyA9IHZsZmllbGQuaXNUeXBlcztcblxuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBST1cpIHx8IHZsZW5jLmhhcyhlbmMsIENPTCkgfHxcbiAgICAgICF2bGVuYy5oYXMoZW5jLCBYKSB8fCAhdmxlbmMuaGFzKGVuYywgWSkgfHxcbiAgICAgICFFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbihzcGVjLCBzdGF0cykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCBpc1R5cGVzKGVuYy54LCBbTixPXSkgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLnkpKSA/ICd4JyA6XG4gICAgICAoIGlzVHlwZXMoZW5jLnksIFtOLE9dKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueCkpID8gJ3knIDogZmFsc2U7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgc3BlYy5jb25maWcgPSBzcGVjLmNvbmZpZyB8fCB7fTtcbiAgICBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsID0gc3BlYy5jb25maWcuZmlsdGVyTnVsbCB8fCB7IC8vRklYTUVcbiAgICAgIFQ6IHRydWUsXG4gICAgICBROiB0cnVlXG4gICAgfTtcbiAgICBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsLk8gPSAhc3BlYy5jb25maWcuZmlsdGVyTnVsbC5PO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZUZpbHRlck51bGxPLnN1cHBvcnQgPSBmdW5jdGlvbihzcGVjLCBzdGF0cykge1xuICAgIHZhciBmaWVsZHMgPSB2bGVuYy5maWVsZHMoc3BlYy5lbmNvZGluZyk7XG4gICAgZm9yICh2YXIgZmllbGROYW1lIGluIGZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkTGlzdCA9IGZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgaWYgKGZpZWxkTGlzdC5jb250YWluc1R5cGUuTyAmJiBmaWVsZE5hbWUgaW4gc3RhdHMgJiYgc3RhdHNbZmllbGROYW1lXS5udWxscyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gRW5jb2Rpbmc7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFnZ3JlZ2F0ZXM7XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZXMoZGF0YVRhYmxlLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICB2YXIgZGltcyA9IHt9LCBtZWFzID0ge30sIGRldGFpbCA9IHt9LCBmYWNldHMgPSB7fTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICBtZWFzLmNvdW50ID0ge29wOiAnY291bnQnLCBmaWVsZDogJyonfTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgbWVhc1tmaWVsZC5hZ2dyZWdhdGUgKyAnfCcrIGZpZWxkLm5hbWVdID0ge1xuICAgICAgICAgIG9wOiBmaWVsZC5hZ2dyZWdhdGUsXG4gICAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUsIHtub2ZuOiB0cnVlfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGltc1tmaWVsZC5uYW1lXSA9IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpO1xuICAgICAgaWYgKGVuY1R5cGUgPT0gUk9XIHx8IGVuY1R5cGUgPT0gQ09MKSB7XG4gICAgICAgIGZhY2V0c1tmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9ZWxzZSBpZiAoZW5jVHlwZSAhPT0gWCAmJiBlbmNUeXBlICE9PSBZKSB7XG4gICAgICAgIGRldGFpbFtmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGltcyA9IHV0aWwudmFscyhkaW1zKTtcbiAgbWVhcyA9IHV0aWwudmFscyhtZWFzKTtcblxuICBpZiAobWVhcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCFkYXRhVGFibGUudHJhbnNmb3JtKSBkYXRhVGFibGUudHJhbnNmb3JtID0gW107XG4gICAgZGF0YVRhYmxlLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogZGltcyxcbiAgICAgIGZpZWxkczogbWVhc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGV0YWlsczogdXRpbC52YWxzKGRldGFpbCksXG4gICAgZGltczogZGltcyxcbiAgICBmYWNldHM6IHV0aWwudmFscyhmYWNldHMpLFxuICAgIGFnZ3JlZ2F0ZWQ6IG1lYXMubGVuZ3RoID4gMFxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcixcbiAgZ2V0dGVyID0gdXRpbC5nZXR0ZXIsXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGF4aXMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5heGlzLm5hbWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgcmV0dXJuIHV0aWwua2V5cyh1dGlsLmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7XG4gICAgdmFyIHMgPSBwcm9wc1t4XS5zY2FsZTtcbiAgICBpZiAocyA9PT0gWCB8fCBzID09PSBZKSBhW3Byb3BzW3hdLnNjYWxlXSA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KSk7XG59O1xuXG5heGlzLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICBhLnB1c2goYXhpcy5kZWYobmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkpO1xuICAgIHJldHVybiBhO1xuICB9LCBbXSk7XG59O1xuXG5heGlzLmRlZiA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBuYW1lO1xuICB2YXIgaXNDb2wgPSBuYW1lID09IENPTCwgaXNSb3cgPSBuYW1lID09IFJPVztcbiAgdmFyIHJvd09mZnNldCA9IGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBZKSArIDIwLFxuICAgIGNlbGxQYWRkaW5nID0gbGF5b3V0LmNlbGxQYWRkaW5nO1xuXG5cbiAgaWYgKGlzQ29sKSB0eXBlID0gJ3gnO1xuICBpZiAoaXNSb3cpIHR5cGUgPSAneSc7XG5cbiAgdmFyIGRlZiA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBuYW1lXG4gIH07XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZ3JpZCkge1xuICAgIGRlZi5ncmlkID0gdHJ1ZTtcbiAgICBkZWYubGF5ZXIgPSAnYmFjayc7XG5cbiAgICBpZiAoaXNDb2wpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHJpZ2h0IHRoZSBjZWxsXG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnZ3JpZCddLCB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBvZmZzZXQ6IGxheW91dC5jZWxsV2lkdGggKiAoMSsgY2VsbFBhZGRpbmcvMi4wKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ2NvbCdcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHZhbHVlOiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzUm93KSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSB0b3BcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdncmlkJ10sIHtcbiAgICAgICAgeToge1xuICAgICAgICAgIG9mZnNldDogLWxheW91dC5jZWxsSGVpZ2h0ICogKGNlbGxQYWRkaW5nLzIpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAncm93J1xuICAgICAgICB9LFxuICAgICAgICB4OiB7XG4gICAgICAgICAgdmFsdWU6IHJvd09mZnNldFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIG9mZnNldDogcm93T2Zmc2V0ICsgKGxheW91dC5jZWxsV2lkdGggKiAwLjA1KSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBncm91cDogJ21hcmsuZ3JvdXAud2lkdGgnLFxuICAgICAgICAgIG11bHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnZ3JpZCddLCB7XG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2dyaWRPcGFjaXR5JykgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGUpIHtcbiAgICBkZWYgPSBheGlzX3RpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcbiAgfVxuXG4gIGlmIChpc1JvdyB8fCBpc0NvbCkge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICd0aWNrcyddLCB7XG4gICAgICBvcGFjaXR5OiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ21ham9yVGlja3MnXSwge1xuICAgICAgb3BhY2l0eToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdheGlzJ10sIHtcbiAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0NvbCkge1xuICAgIGRlZi5vcmllbnQgPSAndG9wJztcbiAgfVxuXG4gIGlmIChpc1Jvdykge1xuICAgIGRlZi5vZmZzZXQgPSByb3dPZmZzZXQ7XG4gIH1cblxuICBpZiAobmFtZSA9PSBYKSB7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSAmJiBlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSAmJiBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgPiAzMCkge1xuICAgICAgZGVmLm9yaWVudCA9ICd0b3AnO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZy5pc0RpbWVuc2lvbihYKSB8fCBlbmNvZGluZy5pc1R5cGUoWCwgVCkpIHtcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscyddLCB7XG4gICAgICAgIGFuZ2xlOiB7dmFsdWU6IDI3MH0sXG4gICAgICAgIGFsaWduOiB7dmFsdWU6ICdyaWdodCd9LFxuICAgICAgICBiYXNlbGluZToge3ZhbHVlOiAnbWlkZGxlJ31cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7IC8vIFFcbiAgICAgIGRlZi50aWNrcyA9IDU7XG4gICAgfVxuICB9XG5cbiAgZGVmID0gYXhpc19sYWJlbHMoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpO1xuXG4gIHJldHVybiBkZWY7XG59O1xuXG5mdW5jdGlvbiBheGlzX3RpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgbWF4bGVuZ3RoID0gbnVsbCxcbiAgICBmaWVsZFRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcbiAgaWYgKG5hbWU9PT1YKSB7XG4gICAgbWF4bGVuZ3RoID0gbGF5b3V0LmNlbGxXaWR0aCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBZKSB7XG4gICAgbWF4bGVuZ3RoID0gbGF5b3V0LmNlbGxIZWlnaHQgLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gIH1cblxuICBkZWYudGl0bGUgPSBtYXhsZW5ndGggPyB1dGlsLnRydW5jYXRlKGZpZWxkVGl0bGUsIG1heGxlbmd0aCkgOiBmaWVsZFRpdGxlO1xuXG4gIGlmIChuYW1lID09PSBST1cpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCd0aXRsZSddLCB7XG4gICAgICBhbmdsZToge3ZhbHVlOiAwfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6ICdyaWdodCd9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9LFxuICAgICAgZHk6IHt2YWx1ZTogKC1sYXlvdXQuaGVpZ2h0LzIpIC0yMH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlZi50aXRsZU9mZnNldCA9IGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBuYW1lKTtcbiAgcmV0dXJuIGRlZjtcbn1cblxuZnVuY3Rpb24gYXhpc19sYWJlbHMoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuXG4gIHZhciB0aW1lVW5pdDtcbiAgLy8gYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgKHRpbWVVbml0ID0gZW5jb2RpbmcudGltZVVuaXQobmFtZSkpICYmICh0aW1lLmhhc1NjYWxlKHRpbWVVbml0KSkpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0Jywnc2NhbGUnXSwgJ3RpbWUtJysgdGltZVVuaXQpO1xuICB9XG5cbiAgdmFyIHRleHRUZW1wbGF0ZVBhdGggPSBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0JywndGVtcGxhdGUnXTtcbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0KSB7XG4gICAgZGVmLmZvcm1hdCA9IGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0O1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBRKSkge1xuICAgIHNldHRlcihkZWYsIHRleHRUZW1wbGF0ZVBhdGgsICd7e2RhdGEgfCBudW1iZXI6XFwnLjNzXFwnfX0nKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkpIHtcbiAgICBpZiAoIWVuY29kaW5nLnRpbWVVbml0KG5hbWUpKSB7XG4gICAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCAne3tkYXRhIHwgdGltZTpcXCclWS0lbS0lZFxcJ319Jyk7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy50aW1lVW5pdChuYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCAne3tkYXRhIHwgbnVtYmVyOlxcJ2RcXCd9fScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgW04sIE9dKSAmJiBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgJ3t7ZGF0YSB8IHRydW5jYXRlOicgKyBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoICsgJ319Jyk7XG4gIH1cblxuICByZXR1cm4gZGVmO1xufVxuXG5mdW5jdGlvbiBheGlzVGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSkge1xuICB2YXIgdmFsdWUgPSBlbmNvZGluZy5heGlzKG5hbWUpLnRpdGxlT2Zmc2V0O1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmlubmluZztcblxuZnVuY3Rpb24gYmlubmluZyhkYXRhVGFibGUsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIGlmICghZGF0YVRhYmxlLnRyYW5zZm9ybSkgZGF0YVRhYmxlLnRyYW5zZm9ybSA9IFtdO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2RpbmcuYmluKGVuY1R5cGUpKSB7XG4gICAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmluJyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUsIGZhbHNlLCAvKm5vZm4qLyB0cnVlKSxcbiAgICAgICAgb3V0cHV0OiBlbmNvZGluZy5maWVsZChlbmNUeXBlKSxcbiAgICAgICAgbWF4YmluczogZW5jb2RpbmcuYmluKGVuY1R5cGUpLm1heGJpbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGFUYWJsZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1bW1hcnkgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJykuc3VtbWFyeTtcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7XG5cbnZhciBFbmNvZGluZyA9IHJlcXVpcmUoJy4uL0VuY29kaW5nJyksXG4gIGF4aXMgPSBjb21waWxlLmF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgZmlsdGVyID0gY29tcGlsZS5maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpLFxuICBsZWdlbmQgPSBjb21waWxlLmxlZ2VuZCA9IHJlcXVpcmUoJy4vbGVnZW5kJyksXG4gIG1hcmtzID0gY29tcGlsZS5tYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKSxcbiAgc2NhbGUgPSBjb21waWxlLnNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5jb21waWxlLmFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vYWdncmVnYXRlJyk7XG5jb21waWxlLmJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG5jb21waWxlLmZhY2V0ID0gcmVxdWlyZSgnLi9mYWNldCcpO1xuY29tcGlsZS5ncm91cCA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcbmNvbXBpbGUubGF5b3V0ID0gcmVxdWlyZSgnLi9sYXlvdXQnKTtcbmNvbXBpbGUuc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpO1xuY29tcGlsZS5zdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKTtcbmNvbXBpbGUuc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5jb21waWxlLnN1YmZhY2V0ID0gcmVxdWlyZSgnLi9zdWJmYWNldCcpO1xuY29tcGlsZS50ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbmNvbXBpbGUudGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG5mdW5jdGlvbiBjb21waWxlKHNwZWMsIHN0YXRzLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZS5lbmNvZGluZyhFbmNvZGluZy5mcm9tU3BlYyhzcGVjLCB0aGVtZSksIHN0YXRzKTtcbn1cblxuY29tcGlsZS5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc2hvcnRoYW5kLCBzdGF0cywgY29uZmlnLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZS5lbmNvZGluZyhFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgY29uZmlnLCB0aGVtZSksIHN0YXRzKTtcbn07XG5cbmNvbXBpbGUuZW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIC8vIG5vIG5lZWQgdG8gcGFzcyBzdGF0cyBpZiB5b3UgcGFzcyBpbiB0aGUgZGF0YVxuICBpZiAoIXN0YXRzICYmIGVuY29kaW5nLmhhc1ZhbHVlcygpKSB7XG4gICAgc3RhdHMgPSBzdW1tYXJ5KGVuY29kaW5nLmRhdGEoJ3ZhbHVlcycpKS5yZWR1Y2UoZnVuY3Rpb24ocywgcCkge1xuICAgICAgc1twLmZpZWxkXSA9IHA7XG4gICAgICByZXR1cm4gcztcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgbGF5b3V0ID0gY29tcGlsZS5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBzcGVjID0gY29tcGlsZS50ZW1wbGF0ZShlbmNvZGluZywgbGF5b3V0LCBzdGF0cyk7XG5cbiAgLy8gLmRhdGEgcmVsYXRlZCBzdHVmZlxuICB2YXIgcmF3VGFibGUgPSBzcGVjLmRhdGFbMF0sXG4gICAgZGF0YVRhYmxlID0gc3BlYy5kYXRhWzFdO1xuXG4gIHJhd1RhYmxlID0gZmlsdGVyLmFkZEZpbHRlcnMocmF3VGFibGUsIGVuY29kaW5nKTsgLy8gbW9kaWZ5IHJhd1RhYmxlXG4gIGRhdGFUYWJsZSA9IGNvbXBpbGUuYmluKGRhdGFUYWJsZSwgZW5jb2RpbmcpOyAgICAgLy8gbW9kaWZ5IGRhdGFUYWJsZVxuICBzcGVjID0gY29tcGlsZS50aW1lKHNwZWMsIGVuY29kaW5nKTsgICAgICAgICAgICAgIC8vIG1vZGlmeSBkYXRhVGFibGUsIGFkZCBzY2FsZXNcbiAgdmFyIGFnZ1Jlc3VsdCA9IGNvbXBpbGUuYWdncmVnYXRlKGRhdGFUYWJsZSwgZW5jb2RpbmcpOyAvLyBtb2RpZnkgZGF0YVRhYmxlXG4gIHZhciBzb3J0aW5nID0gY29tcGlsZS5zb3J0KHNwZWMuZGF0YSwgZW5jb2RpbmcsIHN0YXRzKTsgLy8gYXBwZW5kIG5ldyBkYXRhXG5cbiAgLy8gbWFya3NcbiAgdmFyIHN0eWxlID0gY29tcGlsZS5zdHlsZShlbmNvZGluZywgc3RhdHMpLFxuICAgIGdyb3VwID0gc3BlYy5tYXJrc1swXSxcbiAgICBtYXJrID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0sXG4gICAgbWRlZnMgPSBtYXJrcy5kZWYobWFyaywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUpLFxuICAgIG1kZWYgPSBtZGVmc1swXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXAubWFya3MucHVzaChtZGVmc1tpXSk7XG4gIH1cblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcblxuICB2YXIgZGV0YWlscyA9IGFnZ1Jlc3VsdC5kZXRhaWxzLFxuICAgIGhhc0RldGFpbHMgPSBkZXRhaWxzICYmIGRldGFpbHMubGVuZ3RoID4gMCxcbiAgICBzdGFjayA9IGhhc0RldGFpbHMgJiYgY29tcGlsZS5zdGFjayhzcGVjLmRhdGEsIGVuY29kaW5nLCBtZGVmLCBhZ2dSZXN1bHQuZmFjZXRzKTsgLy8gbW9kaWZ5IHNwZWMuZGF0YSwgbWRlZi57ZnJvbSxwcm9wZXJ0aWVzfVxuXG4gIGlmIChoYXNEZXRhaWxzICYmIChzdGFjayB8fCBsaW5lVHlwZSkpIHtcbiAgICAvL3N1YmZhY2V0IHRvIGdyb3VwIHN0YWNrIC8gbGluZSB0b2dldGhlciBpbiBvbmUgZ3JvdXBcbiAgICBjb21waWxlLnN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gYXV0by1zb3J0IGxpbmUvYXJlYSB2YWx1ZXNcbiAgLy9UT0RPKGthbml0dyk6IGhhdmUgc29tZSBjb25maWcgdG8gdHVybiBvZmYgYXV0by1zb3J0IGZvciBsaW5lIChmb3IgbGluZSBjaGFydCB0aGF0IGVuY29kZXMgdGVtcG9yYWwgaW5mb3JtYXRpb24pXG4gIGlmIChsaW5lVHlwZSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgLy8gVE9ETzogd2h5IC0gP1xuICAgIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe3R5cGU6ICdzb3J0JywgYnk6ICctJyArIGVuY29kaW5nLmZpZWxkKGYpfV07XG4gIH1cblxuICAvLyBTbWFsbCBNdWx0aXBsZXNcbiAgaWYgKGVuY29kaW5nLmhhcyhST1cpIHx8IGVuY29kaW5nLmhhcyhDT0wpKSB7XG4gICAgc3BlYyA9IGNvbXBpbGUuZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpO1xuICAgIHNwZWMubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cC5zY2FsZXMgPSBzY2FsZS5kZWZzKHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgc3R5bGUsIHNvcnRpbmcsIHtzdGFjazogc3RhY2t9KTtcbiAgICBncm91cC5heGVzID0gYXhpcy5kZWZzKGF4aXMubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKTtcbiAgICBncm91cC5sZWdlbmRzID0gbGVnZW5kLmRlZnMoZW5jb2RpbmcpO1xuICB9XG5cbiAgZmlsdGVyLmZpbHRlckxlc3NUaGFuWmVybyhkYXRhVGFibGUsIGVuY29kaW5nKTtcblxuICByZXR1cm4gc3BlYztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmLFxuICBzY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWNldGluZztcblxuZnVuY3Rpb24gZmFjZXRpbmcoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpIHtcbiAgdmFyIGVudGVyID0gZ3JvdXAucHJvcGVydGllcy5lbnRlcjtcbiAgdmFyIGZhY2V0S2V5cyA9IFtdLCBjZWxsQXhlcyA9IFtdLCBmcm9tLCBheGVzR3JwO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgZW50ZXIuZmlsbCA9IHt2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsQmFja2dyb3VuZENvbG9yJyl9O1xuXG4gIC8vbW92ZSBcImZyb21cIiB0byBjZWxsIGxldmVsIGFuZCBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIGdyb3VwLmZyb20gPSB7ZGF0YTogZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhfTtcblxuICAvLyBIYWNrLCB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJrID0gZ3JvdXAubWFya3NbaV07XG4gICAgaWYgKG1hcmsuZnJvbS50cmFuc2Zvcm0pIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb20uZGF0YTsgLy9uZWVkIHRvIGtlZXAgdHJhbnNmb3JtIGZvciBzdWJmYWNldHRpbmcgY2FzZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNSb3cpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKFJPVykpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ1JvdyBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueSA9IHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLmhlaWdodCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkKFJPVykpO1xuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZChDT0wpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneC1heGVzJywge1xuICAgICAgICBheGVzOiBlbmNvZGluZy5oYXMoWCkgPyBheGlzLmRlZnMoWyd4J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4wJ30gOiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDogaGFzQ29sICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofSwgLy9IQUNLP1xuICAgICAgICBmcm9tOiBmcm9tXG4gICAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoWydyb3cnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIHJvd1xuICAgIGlmIChlbmNvZGluZy5oYXMoWCkpIHtcbiAgICAgIC8va2VlcCB4IGF4aXMgaW4gdGhlIGNlbGxcbiAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbJ3gnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzQ29sKSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihDT0wpKSB7XG4gICAgICB1dGlsLmVycm9yKCdDb2wgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnggPSB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLicgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICBlbnRlci53aWR0aCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGQoQ09MKSk7XG5cbiAgICBpZiAoaGFzUm93KSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkKFJPVyldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd5LWF4ZXMnLCB7XG4gICAgICBheGVzOiBlbmNvZGluZy5oYXMoWSkgPyBheGlzLmRlZnMoWyd5J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgIHk6IGhhc1JvdyAmJiB7c2NhbGU6IFJPVywgZmllbGQ6ICdrZXlzLjAnfSxcbiAgICAgIHg6IGhhc1JvdyAmJiB7dmFsdWU6IDB9LFxuICAgICAgaGVpZ2h0OiBoYXNSb3cgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fSwgLy9IQUNLP1xuICAgICAgZnJvbTogZnJvbVxuICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbJ2NvbCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgY29sXG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSkge1xuICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFsneSddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGVxdWFsIGNlbGxXaWR0aCBoZXJlXG4gIC8vIFRPRE86IHN1cHBvcnQgaGV0ZXJvZ2Vub3VzIGNlbGxXaWR0aCAobWF5YmUgYnkgdXNpbmcgbXVsdGlwbGUgc2NhbGVzPylcbiAgc3BlYy5zY2FsZXMgPSAoc3BlYy5zY2FsZXMgfHwgW10pLmNvbmNhdChzY2FsZS5kZWZzKFxuICAgIHNjYWxlLm5hbWVzKGVudGVyKS5jb25jYXQoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSkpLFxuICAgIGVuY29kaW5nLFxuICAgIGxheW91dCxcbiAgICBzdGF0cyxcbiAgICBzdHlsZSxcbiAgICBzb3J0aW5nLFxuICAgIHtzdGFjazogc3RhY2ssIGZhY2V0OiB0cnVlfVxuICApKTsgLy8gcm93L2NvbCBzY2FsZXMgKyBjZWxsIHNjYWxlc1xuXG4gIGlmIChjZWxsQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgZ3JvdXAuYXhlcyA9IGNlbGxBeGVzO1xuICB9XG5cbiAgLy8gYWRkIGZhY2V0IHRyYW5zZm9ybVxuICB2YXIgdHJhbnMgPSAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gfHwgKGdyb3VwLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZmFjZXRLZXlzfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGZpbHRlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBCSU5BUlkgPSB7XG4gICc+JzogIHRydWUsXG4gICc+PSc6IHRydWUsXG4gICc9JzogIHRydWUsXG4gICchPSc6IHRydWUsXG4gICc8JzogIHRydWUsXG4gICc8PSc6IHRydWVcbn07XG5cbmZpbHRlci5hZGRGaWx0ZXJzID0gZnVuY3Rpb24ocmF3VGFibGUsIGVuY29kaW5nKSB7XG4gIHZhciBmaWx0ZXJzID0gZW5jb2RpbmcuZmlsdGVyKCk7ICAvLyBhcHBseSBmaWx0ZXJzIHRvIHJhdyBkYXRhIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gIGlmICghcmF3VGFibGUudHJhbnNmb3JtKVxuICAgIHJhd1RhYmxlLnRyYW5zZm9ybSA9IFtdO1xuXG4gIC8vIGFkZCBjdXN0b20gZmlsdGVyc1xuICBmb3IgKHZhciBpIGluIGZpbHRlcnMpIHtcbiAgICB2YXIgZmlsdGVyID0gZmlsdGVyc1tpXTtcblxuICAgIHZhciBjb25kaXRpb24gPSAnJztcbiAgICB2YXIgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3I7XG4gICAgdmFyIG9wZXJhbmRzID0gZmlsdGVyLm9wZXJhbmRzO1xuXG4gICAgdmFyIGQgPSAnZC4nICsgKGVuY29kaW5nLl92ZWdhMiA/ICcnIDogJ2RhdGEuJyk7XG5cbiAgICBpZiAoQklOQVJZW29wZXJhdG9yXSkge1xuICAgICAgLy8gZXhwZWN0cyBhIGZpZWxkIGFuZCBhIHZhbHVlXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICBvcGVyYXRvciA9ICc9PSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcDEgPSBvcGVyYW5kc1swXTtcbiAgICAgIHZhciBvcDIgPSBvcGVyYW5kc1sxXTtcbiAgICAgIGNvbmRpdGlvbiA9IGQgKyBvcDEgKyBvcGVyYXRvciArIG9wMjtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90TnVsbCcpIHtcbiAgICAgIC8vIGV4cGVjdHMgYSBudW1iZXIgb2YgZmllbGRzXG4gICAgICBmb3IgKHZhciBqIGluIG9wZXJhbmRzKSB7XG4gICAgICAgIGNvbmRpdGlvbiArPSBkICsgb3BlcmFuZHNbal0gKyAnIT09bnVsbCc7XG4gICAgICAgIGlmIChqIDwgb3BlcmFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbmRpdGlvbiArPSAnICYmICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJywgb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJhd1RhYmxlLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgdGVzdDogY29uZGl0aW9uXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmF3VGFibGU7XG59O1xuXG4vLyByZW1vdmUgbGVzcyB0aGFuIDAgdmFsdWVzIGlmIHdlIHVzZSBsb2cgZnVuY3Rpb25cbmZpbHRlci5maWx0ZXJMZXNzVGhhblplcm8gPSBmdW5jdGlvbihkYXRhVGFibGUsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2Rpbmcuc2NhbGUoZW5jVHlwZSkudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgIGRhdGFUYWJsZS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgICB0ZXN0OiAnZC4nICsgZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkgKyAnPjAnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmOiBncm91cGRlZlxufTtcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBmcm9tOiBvcHQuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiBvcHQueCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHk6IG9wdC55IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7Z3JvdXA6ICd3aWR0aCd9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiAnaGVpZ2h0J31cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gdmxsYXlvdXQ7XG5cbmZ1bmN0aW9uIHZsbGF5b3V0KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gYm94KGVuY29kaW5nLCBzdGF0cyk7XG4gIGxheW91dCA9IG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qXG4gIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICovXG5mdW5jdGlvbiBib3goZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSxcbiAgICAgIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpLFxuICAgICAgaGFzWCA9IGVuY29kaW5nLmhhcyhYKSxcbiAgICAgIGhhc1kgPSBlbmNvZGluZy5oYXMoWSksXG4gICAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlKCk7XG5cbiAgLy8gRklYTUUvSEFDSyB3ZSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuICB2YXIgeENhcmRpbmFsaXR5ID0gaGFzWCAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihYKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFgsIHN0YXRzKSA6IDEsXG4gICAgeUNhcmRpbmFsaXR5ID0gaGFzWSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA6IDE7XG5cbiAgdmFyIHVzZVNtYWxsQmFuZCA9IHhDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKSB8fFxuICAgIHlDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKTtcblxuICB2YXIgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcblxuICAvLyBzZXQgY2VsbFdpZHRoXG4gIGlmIChoYXNYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFgpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGVuY29kaW5nLmJhbmQoWCkucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShYLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZW5jKENPTCkud2lkdGggOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVXaWR0aCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmNvbmZpZygndGV4dENlbGxXaWR0aCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShYKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgY2VsbEhlaWdodFxuICBpZiAoaGFzWSkge1xuICAgIGlmIChlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSkge1xuICAgICAgLy8gZm9yIG9yZGluYWwsIGhhc0NvbCBvciBub3QgZG9lc24ndCBtYXR0ZXIgLS0gd2Ugc2NhbGUgYmFzZWQgb24gY2FyZGluYWxpdHlcbiAgICAgIGNlbGxIZWlnaHQgPSAoeUNhcmRpbmFsaXR5ICsgZW5jb2RpbmcuYmFuZChZKS5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFksIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxIZWlnaHQgPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZW5jKFJPVykuaGVpZ2h0IDogIGVuY29kaW5nLmNvbmZpZygnc2luZ2xlSGVpZ2h0Jyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbGxIZWlnaHQgPSBlbmNvZGluZy5iYW5kU2l6ZShZKTtcbiAgfVxuXG4gIC8vIENlbGwgYmFuZHMgdXNlIHJhbmdlQmFuZHMoKS4gVGhlcmUgYXJlIG4tMSBwYWRkaW5nLiAgT3V0ZXJwYWRkaW5nID0gMCBmb3IgY2VsbHNcblxuICB2YXIgd2lkdGggPSBjZWxsV2lkdGgsIGhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gIGlmIChoYXNDb2wpIHtcbiAgICB2YXIgY29sQ2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB3aWR0aCA9IGNlbGxXaWR0aCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChjb2xDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cbiAgaWYgKGhhc1Jvdykge1xuICAgIHZhciByb3dDYXJkaW5hbGl0eSA9ICBlbmNvZGluZy5jYXJkaW5hbGl0eShST1csIHN0YXRzKTtcbiAgICBoZWlnaHQgPSBjZWxsSGVpZ2h0ICogKCgxICsgY2VsbFBhZGRpbmcpICogKHJvd0NhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2hvbGUgY2VsbFxuICAgIGNlbGxXaWR0aDogY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgY2VsbFBhZGRpbmc6IGNlbGxQYWRkaW5nLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNoYXJ0XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHggYW5kIHksIHN1Y2ggYXMgYmFuZCBzaXplXG4gICAgeDoge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfSxcbiAgICB5OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KSB7XG4gIC8vIEZJWE1FIGRldGVybWluZSBjb25zdGFudCBmb3IgUSBhbmQgVCBpbiBhIG5pY2VyIHdheVxuICByZXR1cm4gZW5jb2RpbmcuaXNUeXBlKGV0LCBRKSA/IDIwIDpcbiAgICBlbmNvZGluZy5pc1R5cGUoZXQsIFQpID8gMjAgOlxuICAgIHN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZShldCldLm1heDtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KSB7XG4gIFtYLCBZXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIG1heExlbmd0aDtcbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oeCkgfHwgZW5jb2RpbmcuaXNUeXBlKHgsIFQpKSB7XG4gICAgICBtYXhMZW5ndGggPSAgZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgeCk7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy5hZ2dyZWdhdGUoeCkgPT09ICdjb3VudCcpIHtcbiAgICAgIC8vYXNzaWduIGRlZmF1bHQgdmFsdWUgZm9yIGNvdW50IGFzIGl0IHdvbid0IGhhdmUgc3RhdHNcbiAgICAgIG1heExlbmd0aCA9ICAzO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKHgsIFEpKSB7XG4gICAgICBpZiAoeD09PVgpIHtcbiAgICAgICAgbWF4TGVuZ3RoID0gMztcbiAgICAgIH0gZWxzZSB7IC8vIFlcbiAgICAgICAgLy9hc3N1bWUgdGhhdCBkZWZhdWx0IGZvcm1hdGluZyBpcyBhbHdheXMgc2hvcnRlciB0aGFuIDdcbiAgICAgICAgbWF4TGVuZ3RoID0gTWF0aC5taW4oZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgeCksIDcpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXR0ZXIobGF5b3V0LFt4LCAnYXhpc1RpdGxlT2Zmc2V0J10sIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKSAqICBtYXhMZW5ndGggKyAyMCk7XG4gIH0pO1xuICByZXR1cm4gbGF5b3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBsZWdlbmQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5sZWdlbmQuZGVmcyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBkZWZzID0gW107XG4gIC8vIFRPRE86IHN1cHBvcnQgYWxwaGFcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5sZWdlbmQoQ09MT1IpKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoQ09MT1IsIGVuY29kaW5nLCB7XG4gICAgICBmaWxsOiBDT0xPUixcbiAgICAgIG9yaWVudDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0laRSkgJiYgZW5jb2RpbmcubGVnZW5kKFNJWkUpKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0hBUEUpICYmIGVuY29kaW5nLmxlZ2VuZChTSEFQRSkpIHtcbiAgICBpZiAoZGVmcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzXG4gICAgICBjb25zb2xlLmVycm9yKCdWZWdhLWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIGxlZ2VuZHMnKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSEFQRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNoYXBlOiBTSEFQRSxcbiAgICAgIG9yaWVudDogZGVmcy5sZW5ndGggPT09IDEgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHByb3BzKSB7XG4gIHZhciBkZWYgPSBwcm9wcywgdGltZVVuaXQ7XG5cbiAgZGVmLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmICh0aW1lVW5pdCA9IGVuY29kaW5nLnRpbWVVbml0KG5hbWUpKSAmJlxuICAgIHRpbWUuaGFzU2NhbGUodGltZVVuaXQpKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBkZWYucHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgbGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyB8fCB7fSxcbiAgICAgIHRleHQgPSBsYWJlbHMudGV4dCA9IGxhYmVscy50ZXh0IHx8IHt9O1xuXG4gICAgdGV4dC5zY2FsZSA9ICd0aW1lLScrIHRpbWVVbml0O1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIG1hcmtzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubWFya3MuZGVmID0gZnVuY3Rpb24obWFyaywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICAvLyB0byBhZGQgYSBiYWNrZ3JvdW5kIHRvIHRleHQsIHdlIG5lZWQgdG8gYWRkIGl0IGJlZm9yZSB0aGUgdGV4dFxuICBpZiAoZW5jb2RpbmcubWFya3R5cGUoKSA9PT0gVEVYVCAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdmFyIGJnID0ge1xuICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICB4Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSxcbiAgICAgIHkyOiB7dmFsdWU6IGxheW91dC5jZWxsSGVpZ2h0fSxcbiAgICAgIGZpbGw6IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlbmNvZGluZy5maWVsZChDT0xPUil9XG4gICAgfTtcbiAgICBkZWZzLnB1c2goe1xuICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICAgIHByb3BlcnRpZXM6IHtlbnRlcjogYmcsIHVwZGF0ZTogYmd9XG4gICAgfSk7XG4gIH1cblxuICAvLyBhZGQgdGhlIG1hcmsgZGVmIGZvciB0aGUgbWFpbiB0aGluZ1xuICB2YXIgcCA9IG1hcmsucHJvcChlbmNvZGluZywgbGF5b3V0LCBzdHlsZSk7XG4gIGRlZnMucHVzaCh7XG4gICAgdHlwZTogbWFyay50eXBlLFxuICAgIGZyb206IHtkYXRhOiBUQUJMRX0sXG4gICAgcHJvcGVydGllczoge2VudGVyOiBwLCB1cGRhdGU6IHB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWZzO1xufTtcblxubWFya3MuYmFyID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHN0YWNrOiB0cnVlLFxuICBwcm9wOiBiYXJfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBhbHBoYTogMX1cbn07XG5cbm1hcmtzLmxpbmUgPSB7XG4gIHR5cGU6ICdsaW5lJyxcbiAgbGluZTogdHJ1ZSxcbiAgcHJvcDogbGluZV9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBkZXRhaWw6MX1cbn07XG5cbm1hcmtzLmFyZWEgPSB7XG4gIHR5cGU6ICdhcmVhJyxcbiAgc3RhY2s6IHRydWUsXG4gIGxpbmU6IHRydWUsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHByb3A6IGFyZWFfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBhbHBoYTogMX1cbn07XG5cbm1hcmtzLnRpY2sgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgcHJvcDogdGlja19wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5jaXJjbGUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ2NpcmNsZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLnNxdWFyZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnc3F1YXJlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiBtYXJrcy5jaXJjbGUuc3VwcG9ydGVkRW5jb2Rpbmdcbn07XG5cbm1hcmtzLnBvaW50ID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogcG9pbnRfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgc2hhcGU6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLnRleHQgPSB7XG4gIHR5cGU6ICd0ZXh0JyxcbiAgcHJvcDogdGV4dF9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd0ZXh0J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgdGV4dDogMX1cbn07XG5cbmZ1bmN0aW9uIGJhcl9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHgncyBhbmQgd2lkdGhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgaWYgKCFlLmhhcyhZKSB8fCBlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3ZhbHVlOiAwfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKFgpKSB7IC8vIGlzIG9yZGluYWxcbiAgICAgICBwLnhjID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgfSBlbHNlIHtcbiAgICAgICBwLnggPSB7dmFsdWU6IDAsIG9mZnNldDogZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIXAueDIpIHtcbiAgICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWCkpIHsgLy8gbm8gWCBvciBYIGlzIG9yZGluYWxcbiAgICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLndpZHRoID0ge1xuICAgICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgICAgb2Zmc2V0OiAtMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIFggaXMgUXVhbnQgb3IgVGltZSBTY2FsZVxuICAgICAgcC53aWR0aCA9IHt2YWx1ZTogMn07XG4gICAgfVxuICB9XG5cbiAgLy8geSdzICYgaGVpZ2h0XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoWSkpIHsgLy8gaXMgb3JkaW5hbFxuICAgICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnkyID0ge2dyb3VwOiAnaGVpZ2h0Jywgb2Zmc2V0OiAtZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG5cbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG5cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBvaW50X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gIH1cblxuICAvLyBzaGFwZVxuICBpZiAoZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHtzY2FsZTogU0hBUEUsIGZpZWxkOiBlLmZpZWxkKFNIQVBFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7dmFsdWU6IGUudmFsdWUoU0hBUEUpfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBsaW5lX3Byb3BzKGUsbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBhcmVhX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueDIgPSB7c2NhbGU6IFgsIHZhbHVlOiAwfTtcbiAgICAgIHAub3JpZW50ID0ge3ZhbHVlOiAnaG9yaXpvbnRhbCd9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2Uge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7c2NhbGU6IFksIHZhbHVlOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIHAueSA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0aWNrX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgICBwLngub2Zmc2V0ID0gLWUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLnkub2Zmc2V0ID0gLWUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNEaW1lbnNpb24oWCkpIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAud2lkdGggPSB7dmFsdWU6IDF9O1xuICB9XG5cbiAgLy8gaGVpZ2h0XG4gIGlmICghZS5oYXMoWSkgfHwgZS5pc0RpbWVuc2lvbihZKSkge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZmlsbGVkX3BvaW50X3Byb3BzKHNoYXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCBsYXlvdXQsIHN0eWxlKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIC8vIHhcbiAgICBpZiAoZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHlcbiAgICBpZiAoZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHNpemVcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICAgIH1cblxuICAgIC8vIHNoYXBlXG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogc2hhcGV9O1xuXG4gICAgLy8gZmlsbFxuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG5cbiAgICAvLyBhbHBoYVxuICAgIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gICAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgaWYgKGUuaGFzKFRFWFQpICYmIGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGgtNX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHt2YWx1ZTogZS5mb250KCdzaXplJyl9O1xuICB9XG5cbiAgLy8gZmlsbFxuICAvLyBjb2xvciBzaG91bGQgYmUgc2V0IHRvIGJhY2tncm91bmRcbiAgcC5maWxsID0ge3ZhbHVlOiAnYmxhY2snfTtcblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH0gZWxzZSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBzdHlsZS5vcGFjaXR5fTtcbiAgfVxuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgaWYgKGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnRleHQgPSB7dGVtcGxhdGU6ICd7eycgKyBlLmZpZWxkKFRFWFQpICsgJyB8IG51bWJlcjpcXCcuM3NcXCd9fSd9O1xuICAgICAgcC5hbGlnbiA9IHt2YWx1ZTogJ3JpZ2h0J307XG4gICAgfSBlbHNlIHtcbiAgICAgIHAudGV4dCA9IHtmaWVsZDogZS5maWVsZChURVhUKX07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAudGV4dCA9IHt2YWx1ZTogJ0FiYyd9O1xuICB9XG5cbiAgcC5mb250ID0ge3ZhbHVlOiBlLmZvbnQoJ2ZhbWlseScpfTtcbiAgcC5mb250V2VpZ2h0ID0ge3ZhbHVlOiBlLmZvbnQoJ3dlaWdodCcpfTtcbiAgcC5mb250U3R5bGUgPSB7dmFsdWU6IGUuZm9udCgnc3R5bGUnKX07XG4gIHAuYmFzZWxpbmUgPSB7dmFsdWU6IGUudGV4dCgnYmFzZWxpbmUnKX07XG5cbiAgcmV0dXJuIHA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICBjb2xvcmJyZXdlciA9IHJlcXVpcmUoJy4uL2xpYi9jb2xvcmJyZXdlci9jb2xvcmJyZXdlcicpLFxuICBpbnRlcnBvbGF0ZUxhYiA9IHJlcXVpcmUoJy4uL2xpYi9kMy1jb2xvci9pbnRlcnBvbGF0ZS1sYWInKTtcblxudmFyIHNjYWxlID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuc2NhbGUubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICBpZiAocHJvcHNbeF0gJiYgcHJvcHNbeF0uc2NhbGUpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbnNjYWxlLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIHN0eWxlLCBzb3J0aW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpLFxuICAgICAgZG9tYWluOiBzY2FsZS5kb21haW4obmFtZSwgZW5jb2RpbmcsIHNvcnRpbmcsIG9wdClcbiAgICB9O1xuICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJyAmJiAhZW5jb2RpbmcuYmluKG5hbWUpICYmIGVuY29kaW5nLnNvcnQobmFtZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzLnNvcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBzdHlsZSwgb3B0KTtcblxuICAgIHJldHVybiAoYS5wdXNoKHMpLCBhKTtcbiAgfSwgW10pO1xufTtcblxuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG5cbiAgc3dpdGNoIChlbmNvZGluZy50eXBlKG5hbWUpKSB7XG4gICAgY2FzZSBOOiAvL2ZhbGwgdGhyb3VnaFxuICAgIGNhc2UgTzogcmV0dXJuICdvcmRpbmFsJztcbiAgICBjYXNlIFQ6XG4gICAgICB2YXIgdGltZVVuaXQgPSBlbmNvZGluZy50aW1lVW5pdChuYW1lKTtcbiAgICAgIHJldHVybiAodGltZVVuaXQgJiYgdGltZS5zY2FsZS50eXBlKHRpbWVVbml0LCBuYW1lKSkgfHwgJ3RpbWUnO1xuICAgIGNhc2UgUTpcbiAgICAgIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IENPTE9SID8gJ2xpbmVhcicgOiAnb3JkaW5hbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2Rpbmcuc2NhbGUobmFtZSkudHlwZTtcbiAgfVxufTtcblxuc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKG5hbWUsIGVuY29kaW5nLCBzb3J0aW5nLCBvcHQpIHtcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciByYW5nZSA9IHRpbWUuc2NhbGUuZG9tYWluKGVuY29kaW5nLnRpbWVVbml0KG5hbWUpLCBuYW1lKTtcbiAgICBpZihyYW5nZSkgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgaWYgKG5hbWUgPT0gb3B0LnN0YWNrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IFNUQUNLRUQsXG4gICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSwge1xuICAgICAgICBkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyLFxuICAgICAgICBmbjogKG9wdC5mYWNldCA/ICdtYXhfJyA6ICcnKSArICdzdW0nXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtkYXRhOiBzb3J0aW5nLmdldERhdGFzZXQobmFtZSksIGZpZWxkOiBlbmNvZGluZy5maWVsZChuYW1lKX07XG59O1xuXG5cbmZ1bmN0aW9uIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBzdHlsZSwgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHNwZWMgPSBlbmNvZGluZy5zY2FsZShzLm5hbWUpO1xuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcudGltZVVuaXQocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gZW5jb2RpbmcudGltZVVuaXQocy5uYW1lKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxIZWlnaHQgPyBbbGF5b3V0LmNlbGxIZWlnaHQsIDBdIDogJ2hlaWdodCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcudGltZVVuaXQocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IGVuY29kaW5nLnRpbWVVbml0KHMubmFtZSkgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJPVzogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxIZWlnaHQ7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTDogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxXaWR0aDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0laRTpcbiAgICAgIGlmIChlbmNvZGluZy5pcygnYmFyJykpIHtcbiAgICAgICAgLy8gRklYTUUgdGhpcyBpcyBkZWZpbml0ZWx5IGluY29ycmVjdFxuICAgICAgICAvLyBidXQgbGV0J3MgZml4IGl0IGxhdGVyIHNpbmNlIGJhciBzaXplIGlzIGEgYmFkIGVuY29kaW5nIGFueXdheVxuICAgICAgICBzLnJhbmdlID0gWzMsIE1hdGgubWF4KGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSldO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzLnJhbmdlID0gWzgsIDQwXTtcbiAgICAgIH0gZWxzZSB7IC8vcG9pbnRcbiAgICAgICAgdmFyIGJhbmRTaXplID0gTWF0aC5taW4oZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKSAtIDE7XG4gICAgICAgIHMucmFuZ2UgPSBbMTAsIDAuOCAqIGJhbmRTaXplKmJhbmRTaXplXTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcy5yYW5nZSA9ICdzaGFwZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHMucmFuZ2UgPSBzY2FsZS5jb2xvcihzLCBlbmNvZGluZywgc3RhdHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBuYW1lOiAnKyBzLm5hbWUpO1xuICB9XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFJPVzpcbiAgICBjYXNlIENPTDpcbiAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcbiAgICAgIHMub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5iYW5kKHMubmFtZSkucGFkZGluZztcbiAgICAgIH1cbiAgfVxufVxuXG5zY2FsZS5jb2xvciA9IGZ1bmN0aW9uKHMsIGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgcmFuZ2UgPSBlbmNvZGluZy5zY2FsZShDT0xPUikucmFuZ2UsXG4gICAgY2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0xPUiwgc3RhdHMpLFxuICAgIHR5cGUgPSBlbmNvZGluZy50eXBlKENPTE9SKTtcblxuICBpZiAocmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBvcmRpbmFsUGFsZXR0ZSA9IGVuY29kaW5nLmNvbmZpZygnb3JkaW5hbFBhbGV0dGUnKTtcbiAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGlmICh0eXBlID09PSBOKSB7XG4gICAgICAgIC8vIHVzZSBjYXRlZ29yaWNhbCBjb2xvciBzY2FsZVxuICAgICAgICBpZiAoY2FyZGluYWxpdHkgPD0gMTApIHtcbiAgICAgICAgICByYW5nZSA9ICdjYXRlZ29yeTEwLWsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gJ2NhdGVnb3J5MjAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FyZGluYWxpdHkgPD0gMikge1xuICAgICAgICAgIHJhbmdlID0gW2NvbG9yYnJld2VyW29yZGluYWxQYWxldHRlXVszXVswXSwgY29sb3JicmV3ZXJbb3JkaW5hbFBhbGV0dGVdWzNdWzJdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZSA9IG9yZGluYWxQYWxldHRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy90aW1lIG9yIHF1YW50aXRhdGl2ZVxuICAgICAgdmFyIHBhbGV0dGUgPSBjb2xvcmJyZXdlcltvcmRpbmFsUGFsZXR0ZV1bOV07XG4gICAgICByYW5nZSA9IFtwYWxldHRlWzBdLCBwYWxldHRlWzhdXTtcbiAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NhbGUuY29sb3IucGFsZXR0ZShyYW5nZSwgY2FyZGluYWxpdHksIHR5cGUpO1xufTtcblxuc2NhbGUuY29sb3IucGFsZXR0ZSA9IGZ1bmN0aW9uKHJhbmdlLCBjYXJkaW5hbGl0eSwgdHlwZSkge1xuICBzd2l0Y2ggKHJhbmdlKSB7XG4gICAgY2FzZSAnY2F0ZWdvcnkxMGsnOlxuICAgICAgLy8gdGFibGVhdSdzIGNhdGVnb3J5IDEwLCBvcmRlcmVkIGJ5IHBlcmNlcHR1YWwga2VybmVsIHN0dWR5IHJlc3VsdHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91d2RhdGEvcGVyY2VwdHVhbC1rZXJuZWxzXG4gICAgICByZXR1cm4gWycjMmNhMDJjJywgJyNlMzc3YzInLCAnIzdmN2Y3ZicsICcjMTdiZWNmJywgJyM4YzU2NGInLCAnI2Q2MjcyOCcsICcjYmNiZDIyJywgJyM5NDY3YmQnLCAnI2ZmN2YwZScsICcjMWY3N2I0J107XG5cbiAgICAvLyBkMy90YWJsZWF1IGNhdGVnb3J5MTAvMjAvMjBiLzIwY1xuICAgIGNhc2UgJ2NhdGVnb3J5MTAnOlxuICAgICAgcmV0dXJuIFsnIzFmNzdiNCcsICcjZmY3ZjBlJywgJyMyY2EwMmMnLCAnI2Q2MjcyOCcsICcjOTQ2N2JkJywgJyM4YzU2NGInLCAnI2UzNzdjMicsICcjN2Y3ZjdmJywgJyNiY2JkMjInLCAnIzE3YmVjZiddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMCc6XG4gICAgICByZXR1cm4gWycjMWY3N2I0JywgJyNhZWM3ZTgnLCAnI2ZmN2YwZScsICcjZmZiYjc4JywgJyMyY2EwMmMnLCAnIzk4ZGY4YScsICcjZDYyNzI4JywgJyNmZjk4OTYnLCAnIzk0NjdiZCcsICcjYzViMGQ1JywgJyM4YzU2NGInLCAnI2M0OWM5NCcsICcjZTM3N2MyJywgJyNmN2I2ZDInLCAnIzdmN2Y3ZicsICcjYzdjN2M3JywgJyNiY2JkMjInLCAnI2RiZGI4ZCcsICcjMTdiZWNmJywgJyM5ZWRhZTUnXTtcblxuICAgIGNhc2UgJ2NhdGVnb3J5MjBiJzpcbiAgICAgIHJldHVybiBbJyMzOTNiNzknLCAnIzUyNTRhMycsICcjNmI2ZWNmJywgJyM5YzllZGUnLCAnIzYzNzkzOScsICcjOGNhMjUyJywgJyNiNWNmNmInLCAnI2NlZGI5YycsICcjOGM2ZDMxJywgJyNiZDllMzknLCAnI2U3YmE1MicsICcjZTdjYjk0JywgJyM4NDNjMzknLCAnI2FkNDk0YScsICcjZDY2MTZiJywgJyNlNzk2OWMnLCAnIzdiNDE3MycsICcjYTU1MTk0JywgJyNjZTZkYmQnLCAnI2RlOWVkNiddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMGMnOlxuICAgICAgcmV0dXJuIFsnIzMxODJiZCcsICcjNmJhZWQ2JywgJyM5ZWNhZTEnLCAnI2M2ZGJlZicsICcjZTY1NTBkJywgJyNmZDhkM2MnLCAnI2ZkYWU2YicsICcjZmRkMGEyJywgJyMzMWEzNTQnLCAnIzc0YzQ3NicsICcjYTFkOTliJywgJyNjN2U5YzAnLCAnIzc1NmJiMScsICcjOWU5YWM4JywgJyNiY2JkZGMnLCAnI2RhZGFlYicsICcjNjM2MzYzJywgJyM5Njk2OTYnLCAnI2JkYmRiZCcsICcjZDlkOWQ5J107XG4gIH1cblxuICBpZiAocmFuZ2UgaW4gY29sb3JicmV3ZXIpIHtcbiAgICB2YXIgcGFsZXR0ZSA9IGNvbG9yYnJld2VyW3JhbmdlXSxcbiAgICAgIHBzID0gNTtcblxuICAgIC8vIGlmIGNhcmRpbmFsaXR5IHByZS1kZWZpbmVkLCB1c2UgaXQuXG4gICAgaWYgKGNhcmRpbmFsaXR5IGluIHBhbGV0dGUpIHJldHVybiBwYWxldHRlW2NhcmRpbmFsaXR5XTtcblxuICAgIC8vIGlmIG5vdCwgdXNlIHRoZSBoaWdoZXN0IGNhcmRpbmFsaXR5IG9uZSBmb3Igbm9taW5hbFxuICAgIGlmICh0eXBlID09PSBOKSB7XG4gICAgICByZXR1cm4gcGFsZXR0ZVtNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLmtleXMocGFsZXR0ZSkpXTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIGludGVycG9sYXRlXG4gICAgcmV0dXJuIHNjYWxlLmNvbG9yLmludGVycG9sYXRlKHBhbGV0dGVbcHNdWzBdLCBwYWxldHRlW3BzXVtwcy0xXSwgY2FyZGluYWxpdHkpO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuc2NhbGUuY29sb3IuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY2FyZGluYWxpdHkpIHtcbiAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRlTGFiKHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gdXRpbC5yYW5nZShjYXJkaW5hbGl0eSkubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGludGVycG9sYXRvcihpKjEuMC8oY2FyZGluYWxpdHktMSkpOyB9KTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU29ydFRyYW5zZm9ybXM7XG5cbi8vIGFkZHMgbmV3IHRyYW5zZm9ybXMgdGhhdCBwcm9kdWNlIHNvcnRlZCBmaWVsZHNcbmZ1bmN0aW9uIGFkZFNvcnRUcmFuc2Zvcm1zKGRhdGEsIGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YXNldE1hcHBpbmcgPSB7fTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgc29ydEJ5ID0gZW5jb2Rpbmcuc29ydChlbmNUeXBlLCBzdGF0cyk7XG4gICAgaWYgKHNvcnRCeS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZmllbGRzID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IGQuYWdncmVnYXRlLFxuICAgICAgICAgIGZpZWxkOiB2bGZpZWxkLmZpZWxkUmVmKGQsIHtub2ZuOiB0cnVlLCBkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnlDbGF1c2UgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UgPSAoZC5yZXZlcnNlID8gJy0nIDogJycpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSArIHZsZmllbGQuZmllbGRSZWYoZCwge2RhdGE6ICFlbmNvZGluZy5fdmVnYTJ9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YU5hbWUgPSAnc29ydGVkJyArIGNvdW50ZXIrKztcblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBbIGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpIF0sXG4gICAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzb3J0JyxcbiAgICAgICAgICBieTogYnlDbGF1c2VcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICAgIHNvdXJjZTogUkFXLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhc2V0TWFwcGluZ1tlbmNUeXBlXSA9IGRhdGFOYW1lO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXREYXRhc2V0OiBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBUQUJMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tpbmc7XG5cbmZ1bmN0aW9uIHN0YWNraW5nKGRhdGEsIGVuY29kaW5nLCBtZGVmLCBmYWNldHMpIHtcbiAgaWYgKCFtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5zdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCB8fCBlbmNvZGluZy5oYXMoTE9EKSBoZXJlIG9uY2UgTE9EIGlzIGltcGxlbWVudGVkXG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW09bnVsbCwgdmFsPW51bGwsIGlkeCA9bnVsbCxcbiAgICBpc1hNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFgpLFxuICAgIGlzWU1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWSk7XG5cbiAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lNZWFzdXJlICYmICFpc1hNZWFzdXJlKSB7XG4gICAgZGltID0gWDtcbiAgICB2YWwgPSBZO1xuICAgIGlkeCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIHN0YWNrIGVuY29kaW5nXG4gIH1cblxuICAvLyBhZGQgdHJhbnNmb3JtIHRvIGNvbXB1dGUgc3VtcyBmb3Igc2NhbGVcbiAgdmFyIHN0YWNrZWQgPSB7XG4gICAgbmFtZTogU1RBQ0tFRCxcbiAgICBzb3VyY2U6IFRBQkxFLFxuICAgIHRyYW5zZm9ybTogW3tcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiAnc3VtJywgZmllbGQ6IGVuY29kaW5nLmZpZWxkKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdncmVnYXRlIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZiAoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RhY2tlZC50cmFuc2Zvcm0ucHVzaCh7IC8vY2FsY3VsYXRlIG1heCBmb3IgZWFjaCBmYWNldFxuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7XG4gICAgICAgIG9wOiAnbWF4JyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkTmFtZSh2YWwsIHtmbjogJ3N1bSd9KVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogJ3N0YWNrJyxcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGQoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCArICcyJ31cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwgKyAnMiddID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCArICcyJ10gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCArICcyJ307XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG5cbiAgICAgIGlmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MICYmXG4gICAgICAgICAgISgoZW5jVHlwZSA9PT0gWCB8fCBlbmNUeXBlID09PSBZKSAmJlxuICAgICAgICAgIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZmllbGQpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuICAgIG51bVBvaW50cyA9IHN0YXRzLmNvdW50O1xuXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzIGRpdmlkZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgdmFyIG51bU11bHRpcGxlcyA9IDE7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhST1cpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIH1cbiAgICBudW1Qb2ludHMgLz0gbnVtTXVsdGlwbGVzO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSAwO1xuICBpZiAobnVtUG9pbnRzIDwgMjApIHtcbiAgICBvcGFjaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAyMDApIHtcbiAgICBvcGFjaXR5ID0gMC43O1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDEwMDAgfHwgZW5jb2RpbmcuaXMoJ3RpY2snKSkge1xuICAgIG9wYWNpdHkgPSAwLjY7XG4gIH0gZWxzZSB7XG4gICAgb3BhY2l0eSA9IDAuMztcbiAgfVxuXG4gIHJldHVybiBvcGFjaXR5O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZjtcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJmYWNldGluZztcblxuZnVuY3Rpb24gc3ViZmFjZXRpbmcoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZykge1xuICB2YXIgbSA9IGdyb3VwLm1hcmtzLFxuICAgIGcgPSBncm91cGRlZignc3ViZmFjZXQnLCB7bWFya3M6IG19KTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZy5mcm9tID0gbWRlZi5mcm9tO1xuICBkZWxldGUgbWRlZi5mcm9tO1xuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGRldGFpbHN9KTtcblxuICBpZiAoc3RhY2sgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdzb3J0JywgYnk6IGVuY29kaW5nLmZpZWxkKENPTE9SKX0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YSA9IHtuYW1lOiBSQVcsIGZvcm1hdDoge319LFxuICAgIHRhYmxlID0ge25hbWU6IFRBQkxFLCBzb3VyY2U6IFJBV30sXG4gICAgZGF0YVVybCA9IGVuY29kaW5nLmRhdGEoJ3VybCcpLFxuICAgIGRhdGFUeXBlID0gZW5jb2RpbmcuZGF0YSgnZm9ybWF0VHlwZScpLFxuICAgIHZhbHVlcyA9IGVuY29kaW5nLmRhdGEoJ3ZhbHVlcycpO1xuXG4gIGlmIChlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIGRhdGEudmFsdWVzID0gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEudXJsID0gZGF0YVVybDtcbiAgICBkYXRhLmZvcm1hdC50eXBlID0gZGF0YVR5cGU7XG4gIH1cblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT0gVCkge1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW2ZpZWxkLm5hbWVdID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PSBRKSB7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgaWYgKHZsZmllbGQuaXNDb3VudChmaWVsZCkpIHtcbiAgICAgICAgbmFtZSA9ICdjb3VudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZmllbGQubmFtZTtcbiAgICAgIH1cbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW25hbWVdID0gJ251bWJlcic7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0LFxuICAgIHBhZGRpbmc6ICdhdXRvJyxcbiAgICBkYXRhOiBbZGF0YSwgdGFibGVdLFxuICAgIG1hcmtzOiBbZ3JvdXBkZWYoJ2NlbGwnLCB7XG4gICAgICB3aWR0aDogbGF5b3V0LmNlbGxXaWR0aCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0gOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGxheW91dC5jZWxsSGVpZ2h0ID8ge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0gOiB1bmRlZmluZWRcbiAgICB9KV1cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZTtcblxuZnVuY3Rpb24gdGltZShzcGVjLCBlbmNvZGluZywgb3B0KSB7IC8vIEZJWE1FIHJlZmFjdG9yIHRvIHJlZHVjZSBzaWRlIGVmZmVjdCAjMjc2XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRpbWVGaWVsZHMgPSB7fSwgdGltZVVuaXRzID0ge307XG5cbiAgLy8gZmluZCB1bmlxdWUgZm9ybXVsYSB0cmFuc2Zvcm1hdGlvbiBhbmQgYmluIGZ1bmN0aW9uXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC50aW1lVW5pdCkge1xuICAgICAgdGltZUZpZWxkc1tlbmNvZGluZy5maWVsZChlbmNUeXBlKV0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZW5jVHlwZTogZW5jVHlwZVxuICAgICAgfTtcbiAgICAgIHRpbWVVbml0c1tmaWVsZC50aW1lVW5pdF0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIGZvcm11bGEgdHJhbnNmb3JtXG4gIHZhciBkYXRhID0gc3BlYy5kYXRhWzFdLFxuICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gfHwgW107XG5cbiAgZm9yICh2YXIgZiBpbiB0aW1lRmllbGRzKSB7XG4gICAgdmFyIHRmID0gdGltZUZpZWxkc1tmXTtcbiAgICB0aW1lLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIGVuY29kaW5nLCB0Zi5lbmNUeXBlLCB0Zi5maWVsZCk7XG4gIH1cblxuICAvLyBhZGQgc2NhbGVzXG4gIHZhciBzY2FsZXMgPSBzcGVjLnNjYWxlcyA9IHNwZWMuc2NhbGVzIHx8IFtdO1xuICBmb3IgKHZhciB0aW1lVW5pdCBpbiB0aW1lVW5pdHMpIHtcbiAgICB0aW1lLnNjYWxlKHNjYWxlcywgdGltZVVuaXQsIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxuXG5cbnRpbWUuY2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwsIHR5cGUpIHtcbiAgdmFyIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQ7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ21pbnV0ZXMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gMjQ7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIDc7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiAzMTtcbiAgICBjYXNlICdtb250aCc6IHJldHVybiAxMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV0sXG4gICAgICAgIHllYXJzdGF0ID0gc3RhdHNbJ3llYXJfJytmaWVsZC5uYW1lXTtcblxuICAgICAgaWYgKCF5ZWFyc3RhdCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICByZXR1cm4geWVhcnN0YXQuZGlzdGluY3QgLVxuICAgICAgICAoc3RhdC5udWxscyA+IDAgJiYgZmlsdGVyTnVsbFt0eXBlXSA/IDEgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gZmllbGRGbihmdW5jLCBmaWVsZCkge1xuICByZXR1cm4gJ3V0YycgKyBmdW5jICsgJyhkLmRhdGEuJysgZmllbGQubmFtZSArJyknO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge1N0cmluZ30gZGF0ZSBiaW5uaW5nIGZvcm11bGEgb2YgdGhlIGdpdmVuIGZpZWxkXG4gKi9cbnRpbWUuZm9ybXVsYSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZEZuKGZpZWxkLnRpbWVVbml0LCBmaWVsZCk7XG59O1xuXG4vKiogYWRkIGZvcm11bGEgdHJhbnNmb3JtcyB0byBkYXRhICovXG50aW1lLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSwgZW5jb2RpbmcsIGVuY1R5cGUsIGZpZWxkKSB7XG4gIHRyYW5zZm9ybS5wdXNoKHtcbiAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpLFxuICAgIGV4cHI6IHRpbWUuZm9ybXVsYShmaWVsZClcbiAgfSk7XG59O1xuXG4vKiogYXBwZW5kIGN1c3RvbSB0aW1lIHNjYWxlcyBmb3IgYXhpcyBsYWJlbCAqL1xudGltZS5zY2FsZSA9IGZ1bmN0aW9uKHNjYWxlcywgdGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHZhciBsYWJlbExlbmd0aCA9IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTGFiZWxMZW5ndGgnKTtcbiAgLy8gVE9ETyBhZGQgb3B0aW9uIGZvciBzaG9ydGVyIHNjYWxlIC8gY3VzdG9tIHJhbmdlXG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdkYXknOlxuICAgICAgc2NhbGVzLnB1c2goe1xuICAgICAgICBuYW1lOiAndGltZS0nK3RpbWVVbml0LFxuICAgICAgICB0eXBlOiAnb3JkaW5hbCcsXG4gICAgICAgIGRvbWFpbjogdXRpbC5yYW5nZSgwLCA3KSxcbiAgICAgICAgcmFuZ2U6IFsnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheScsICdTdW5kYXknXS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtb250aCc6XG4gICAgICBzY2FsZXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICd0aW1lLScrdGltZVVuaXQsXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiB1dGlsLnJhbmdlKDAsIDEyKSxcbiAgICAgICAgcmFuZ2U6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLm1hcChcbiAgICAgICAgICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMuc3Vic3RyKDAsIGxhYmVsTGVuZ3RoKTt9XG4gICAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxudGltZS5pc09yZGluYWxGbiA9IGZ1bmN0aW9uKHRpbWVVbml0KSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG50aW1lLnNjYWxlLnR5cGUgPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICBpZiAobmFtZSA9PT0gQ09MT1IpIHtcbiAgICByZXR1cm4gJ2xpbmVhcic7IC8vIHRoaXMgaGFzIG9yZGVyXG4gIH1cblxuICByZXR1cm4gdGltZS5pc09yZGluYWxGbih0aW1lVW5pdCkgfHwgbmFtZSA9PT0gQ09MIHx8IG5hbWUgPT09IFJPVyA/ICdvcmRpbmFsJyA6ICdsaW5lYXInO1xufTtcblxudGltZS5zY2FsZS5kb21haW4gPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICB2YXIgaXNDb2xvciA9IG5hbWUgPT09IENPTE9SO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiBpc0NvbG9yID8gWzAsNTldIDogdXRpbC5yYW5nZSgwLCA2MCk7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gaXNDb2xvciA/IFswLDIzXSA6IHV0aWwucmFuZ2UoMCwgMjQpO1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiBpc0NvbG9yID8gWzAsNl0gOiB1dGlsLnJhbmdlKDAsIDcpO1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gaXNDb2xvciA/IFsxLDMxXSA6IHV0aWwucmFuZ2UoMSwgMzIpO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIGlzQ29sb3IgPyBbMCwxMV0gOiB1dGlsLnJhbmdlKDAsIDEyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKiB3aGV0aGVyIGEgcGFydGljdWxhciB0aW1lIGZ1bmN0aW9uIGhhcyBjdXN0b20gc2NhbGUgZm9yIGxhYmVscyBpbXBsZW1lbnRlZCBpbiB0aW1lLnNjYWxlICovXG50aW1lLmhhc1NjYWxlID0gZnVuY3Rpb24odGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuY29uc3RzLmVuY29kaW5nVHlwZXMgPSBbWCwgWSwgUk9XLCBDT0wsIFNJWkUsIFNIQVBFLCBDT0xPUiwgQUxQSEEsIFRFWFQsIERFVEFJTF07XG5cbmNvbnN0cy5zaG9ydGhhbmQgPSB7XG4gIGRlbGltOiAgJ3wnLFxuICBhc3NpZ246ICc9JyxcbiAgdHlwZTogICAnLCcsXG4gIGZ1bmM6ICAgJ18nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHZsZGF0YSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gZGF0YWxpYidzIGluZmVycmVkIHR5cGUgdG8gVmVnYS1saXRlJ3MgdHlwZSAqL1xudmxkYXRhLnR5cGVzID0ge1xuICAnYm9vbGVhbic6IE4sXG4gICdudW1iZXInOiBRLFxuICAnaW50ZWdlcic6IFEsXG4gICdkYXRlJzogVCxcbiAgJ3N0cmluZyc6IE5cbn07XG5cbiIsIi8vIHV0aWxpdHkgZm9yIGVuY1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKSxcbiAgZW5jVHlwZXMgPSBzY2hlbWEuZW5jVHlwZXM7XG5cbnZhciB2bGVuYyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZW5jLmNvdW50UmV0aW5hbCA9IGZ1bmN0aW9uKGVuYykge1xuICB2YXIgY291bnQgPSAwO1xuICBpZiAoZW5jLmNvbG9yKSBjb3VudCsrO1xuICBpZiAoZW5jLmFscGhhKSBjb3VudCsrO1xuICBpZiAoZW5jLnNpemUpIGNvdW50Kys7XG4gIGlmIChlbmMuc2hhcGUpIGNvdW50Kys7XG4gIHJldHVybiBjb3VudDtcbn07XG5cbnZsZW5jLmhhcyA9IGZ1bmN0aW9uKGVuYywgZW5jVHlwZSkge1xuICB2YXIgZmllbGREZWYgPSBlbmMgJiYgZW5jW2VuY1R5cGVdO1xuICByZXR1cm4gZmllbGREZWYgJiYgZmllbGREZWYubmFtZTtcbn07XG5cbnZsZW5jLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oZW5jKSB7XG4gIGZvciAodmFyIGsgaW4gZW5jKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspICYmIGVuY1trXS5hZ2dyZWdhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52bGVuYy5mb3JFYWNoID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBpID0gMDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBmKGVuY1trXSwgaywgaSsrKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmxlbmMubWFwID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBhcnIucHVzaChmKGVuY1trXSwgaywgZW5jKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbnZsZW5jLnJlZHVjZSA9IGZ1bmN0aW9uKGVuYywgZiwgaW5pdCkge1xuICB2YXIgciA9IGluaXQ7XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgciA9IGYociwgZW5jW2tdLCBrLCAgZW5jKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG5cbi8qXG4gKiByZXR1cm4ga2V5LXZhbHVlIHBhaXJzIG9mIGZpZWxkIG5hbWUgYW5kIGxpc3Qgb2YgZmllbGRzIG9mIHRoYXQgZmllbGQgbmFtZVxuICovXG52bGVuYy5maWVsZHMgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLnJlZHVjZShlbmMsIGZ1bmN0aW9uIChtLCBmaWVsZCkge1xuICAgIHZhciBmaWVsZExpc3QgPSBtW2ZpZWxkLm5hbWVdID0gbVtmaWVsZC5uYW1lXSB8fCBbXSxcbiAgICAgIGNvbnRhaW5zVHlwZSA9IGZpZWxkTGlzdC5jb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlIHx8IHt9O1xuXG4gICAgaWYgKGZpZWxkTGlzdC5pbmRleE9mKGZpZWxkKSA9PT0gLTEpIHtcbiAgICAgIGZpZWxkTGlzdC5wdXNoKGZpZWxkKTtcbiAgICAgIC8vIGF1Z21lbnQgdGhlIGFycmF5IHdpdGggY29udGFpbnNUeXBlLlEgLyBPIC8gTiAvIFRcbiAgICAgIGNvbnRhaW5zVHlwZVtmaWVsZC50eXBlXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59O1xuXG52bGVuYy5zaG9ydGhhbmQgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLm1hcChlbmMsIGZ1bmN0aW9uKGZpZWxkLCBldCkge1xuICAgIHJldHVybiBldCArIGMuYXNzaWduICsgdmxmaWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCkge1xuICB2YXIgZW5jID0gdXRpbC5pc0FycmF5KHNob3J0aGFuZCkgPyBzaG9ydGhhbmQgOiBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSk7XG4gIHJldHVybiBlbmMucmVkdWNlKGZ1bmN0aW9uKG0sIGUpIHtcbiAgICB2YXIgc3BsaXQgPSBlLnNwbGl0KGMuYXNzaWduKSxcbiAgICAgICAgZW5jdHlwZSA9IHNwbGl0WzBdLnRyaW0oKSxcbiAgICAgICAgZmllbGQgPSBzcGxpdFsxXTtcblxuICAgIG1bZW5jdHlwZV0gPSB2bGZpZWxkLmZyb21TaG9ydGhhbmQoZmllbGQpO1xuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLy8gdXRpbGl0eSBmb3IgZmllbGRcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgdGltZSA9IHJlcXVpcmUoJy4vY29tcGlsZS90aW1lJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG5cbnZhciB2bGZpZWxkID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gZmllbGRcbiAqIEBwYXJhbSBvcHRcbiAqICAgb3B0Lm5vZm4gLS0gZXhjbHVkZSBiaW4sIGFnZ3JlZ2F0ZSwgdGltZVVuaXRcbiAqICAgb3B0LmRhdGEgLSBpbmNsdWRlICdkYXRhLidcbiAqICAgb3B0LmZuIC0gY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xudmxmaWVsZC5maWVsZFJlZiA9IGZ1bmN0aW9uKGZpZWxkLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBmID0gKG9wdC5kYXRhID8gJ2RhdGEuJyA6ICcnKSxcbiAgICBub2ZuID0gb3B0Lm5vZm4gfHwgb3B0LmZuLFxuICAgIG5hbWUgPSBmaWVsZC5uYW1lO1xuXG4gIGlmICh2bGZpZWxkLmlzQ291bnQoZmllbGQpKSB7XG4gICAgcmV0dXJuIGYgKyAnY291bnQnO1xuICB9IGVsc2UgaWYgKCFub2ZuICYmIGZpZWxkLmJpbikge1xuICAgIHJldHVybiBmICsgJ2Jpbl8nICsgbmFtZTtcbiAgfSBlbHNlIGlmICghbm9mbiAmJiBmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICByZXR1cm4gZiArIGZpZWxkLmFnZ3JlZ2F0ZSArICdfJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAoIW5vZm4gJiYgZmllbGQudGltZVVuaXQpIHtcbiAgICByZXR1cm4gZiArIGZpZWxkLnRpbWVVbml0ICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIGlmIChvcHQuZm4pIHtcbiAgICByZXR1cm4gZiArIG9wdC5mbiArICdfJyArIG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGYgKyBuYW1lO1xuICB9XG59O1xuXG52bGZpZWxkLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICByZXR1cm4gKGYuYWdncmVnYXRlID8gZi5hZ2dyZWdhdGUgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLnRpbWVVbml0ID8gZi50aW1lVW5pdCArIGMuZnVuYyA6ICcnKSArXG4gICAgKGYuYmluID8gJ2JpbicgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLm5hbWUgfHwgJycpICsgYy50eXBlICsgZi50eXBlO1xufTtcblxudmxmaWVsZC5zaG9ydGhhbmRzID0gZnVuY3Rpb24oZmllbGRzLCBkZWxpbSkge1xuICBkZWxpbSA9IGRlbGltIHx8IGMuZGVsaW07XG4gIHJldHVybiBmaWVsZHMubWFwKHZsZmllbGQuc2hvcnRoYW5kKS5qb2luKGRlbGltKTtcbn07XG5cbnZsZmllbGQuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCkge1xuICB2YXIgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy50eXBlKSwgaTtcbiAgdmFyIG8gPSB7XG4gICAgbmFtZTogc3BsaXRbMF0udHJpbSgpLFxuICAgIHR5cGU6IHNwbGl0WzFdLnRyaW0oKVxuICB9O1xuXG4gIC8vIGNoZWNrIGFnZ3JlZ2F0ZSB0eXBlXG4gIGZvciAoaSBpbiBzY2hlbWEuYWdncmVnYXRlLmVudW0pIHtcbiAgICB2YXIgYSA9IHNjaGVtYS5hZ2dyZWdhdGUuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyZWdhdGUgPSBhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgdGltZSB0aW1lVW5pdFxuICBmb3IgKGkgaW4gc2NoZW1hLnRpbWVmbnMpIHtcbiAgICB2YXIgdHUgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKHR1ICsgJ18nKSA9PT0gMCkge1xuICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cihvLmxlbmd0aCArIDEpO1xuICAgICAgby50aW1lVW5pdCA9IHR1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgYmluXG4gIGlmIChvLm5hbWUgJiYgby5uYW1lLmluZGV4T2YoJ2Jpbl8nKSA9PT0gMCkge1xuICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoNCk7XG4gICAgby5iaW4gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG87XG59O1xuXG52YXIgdHlwZU9yZGVyID0ge1xuICBOOiAwLFxuICBPOiAxLFxuICBHOiAyLFxuICBUOiAzLFxuICBROiA0XG59O1xuXG52bGZpZWxkLm9yZGVyID0ge307XG5cbnZsZmllbGQub3JkZXIudHlwZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmIChmaWVsZC5hZ2dyZWdhdGU9PT0nY291bnQnKSByZXR1cm4gNDtcbiAgcmV0dXJuIHR5cGVPcmRlcltmaWVsZC50eXBlXTtcbn07XG5cbnZsZmllbGQub3JkZXIudHlwZVRoZW5OYW1lID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIHZsZmllbGQub3JkZXIudHlwZShmaWVsZCkgKyAnXycgKyBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52bGZpZWxkLm9yZGVyLm9yaWdpbmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwOyAvLyBubyBzd2FwIHdpbGwgb2NjdXJcbn07XG5cbnZsZmllbGQub3JkZXIubmFtZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5uYW1lO1xufTtcblxudmxmaWVsZC5vcmRlci50eXBlVGhlbkNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZmllbGQsIHN0YXRzKXtcbiAgcmV0dXJuIHN0YXRzW2ZpZWxkLm5hbWVdLmRpc3RpbmN0O1xufTtcblxudmFyIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlKSB7XG4gIHJldHVybiBmaWVsZERlZi50eXBlID09PSB0eXBlO1xufTtcblxudmFyIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXMgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGVzKSB7XG4gIGZvciAodmFyIHQ9MDsgdDx0eXBlcy5sZW5ndGg7IHQrKykge1xuICAgIGlmKGZpZWxkRGVmLnR5cGUgPT09IHR5cGVzW3RdKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQudGltZVVuaXQgJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC50aW1lVW5pdCkgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLnRpbWVVbml0ICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgaXNEaW1lbnNpb24oZmllbGQpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgIWlzRGltZW5zaW9uKGZpZWxkKTtcbn07XG5cbnZsZmllbGQucm9sZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBpc0RpbWVuc2lvbihmaWVsZCkgPyAnZGltZW5zaW9uJyA6ICdtZWFzdXJlJztcbn07XG5cbnZsZmllbGQuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtuYW1lOicqJywgYWdncmVnYXRlOiAnY291bnQnLCB0eXBlOiBRLCBkaXNwbGF5TmFtZTogdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZX07XG59O1xuXG52bGZpZWxkLmNvdW50LmRpc3BsYXlOYW1lID0gJ051bWJlciBvZiBSZWNvcmRzJztcblxudmxmaWVsZC5pc0NvdW50ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jztcbn07XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuY2FyZGluYWxpdHkoKSB0byBhdm9pZCBjb25mdXNpb24uICBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuY2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcblxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICB2YXIgdHlwZSA9IGZpZWxkLnR5cGU7XG5cbiAgZmlsdGVyTnVsbCA9IGZpbHRlck51bGwgfHwge307XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgaWYgKGlzVHlwZShmaWVsZCwgVCkpIHtcbiAgICB2YXIgY2FyZGluYWxpdHkgPSB0aW1lLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSk7XG4gICAgaWYoY2FyZGluYWxpdHkgIT09IG51bGwpIHJldHVybiBjYXJkaW5hbGl0eTtcbiAgICAvL290aGVyd2lzZSB1c2UgY2FsY3VsYXRpb24gYmVsb3dcbiAgfVxuICBpZiAoZmllbGQuYWdncmVnYXRlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyByZW1vdmUgbnVsbFxuICByZXR1cm4gc3RhdC5kaXN0aW5jdCAtXG4gICAgKHN0YXQubnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLlRBQkxFID0gJ3RhYmxlJztcbmcuUkFXID0gJ3Jhdyc7XG5nLlNUQUNLRUQgPSAnc3RhY2tlZCc7XG5nLklOREVYID0gJ2luZGV4JztcblxuZy5YID0gJ3gnO1xuZy5ZID0gJ3knO1xuZy5ST1cgPSAncm93JztcbmcuQ09MID0gJ2NvbCc7XG5nLlNJWkUgPSAnc2l6ZSc7XG5nLlNIQVBFID0gJ3NoYXBlJztcbmcuQ09MT1IgPSAnY29sb3InO1xuZy5BTFBIQSA9ICdhbHBoYSc7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk4gPSAnTic7XG5nLk8gPSAnTyc7XG5nLlEgPSAnUSc7XG5nLlQgPSAnVCc7XG4iLCIvLyBUaGlzIHByb2R1Y3QgaW5jbHVkZXMgY29sb3Igc3BlY2lmaWNhdGlvbnMgYW5kIGRlc2lnbnMgZGV2ZWxvcGVkIGJ5IEN5bnRoaWEgQnJld2VyIChodHRwOi8vY29sb3JicmV3ZXIub3JnLykuXG5tb2R1bGUuZXhwb3J0cyA9IHtZbEduOiB7XG4zOiBbJyNmN2ZjYjknLCcjYWRkZDhlJywnIzMxYTM1NCddLFxuNDogWycjZmZmZmNjJywnI2MyZTY5OScsJyM3OGM2NzknLCcjMjM4NDQzJ10sXG41OiBbJyNmZmZmY2MnLCcjYzJlNjk5JywnIzc4YzY3OScsJyMzMWEzNTQnLCcjMDA2ODM3J10sXG42OiBbJyNmZmZmY2MnLCcjZDlmMGEzJywnI2FkZGQ4ZScsJyM3OGM2NzknLCcjMzFhMzU0JywnIzAwNjgzNyddLFxuNzogWycjZmZmZmNjJywnI2Q5ZjBhMycsJyNhZGRkOGUnLCcjNzhjNjc5JywnIzQxYWI1ZCcsJyMyMzg0NDMnLCcjMDA1YTMyJ10sXG44OiBbJyNmZmZmZTUnLCcjZjdmY2I5JywnI2Q5ZjBhMycsJyNhZGRkOGUnLCcjNzhjNjc5JywnIzQxYWI1ZCcsJyMyMzg0NDMnLCcjMDA1YTMyJ10sXG45OiBbJyNmZmZmZTUnLCcjZjdmY2I5JywnI2Q5ZjBhMycsJyNhZGRkOGUnLCcjNzhjNjc5JywnIzQxYWI1ZCcsJyMyMzg0NDMnLCcjMDA2ODM3JywnIzAwNDUyOSddXG59LFlsR25CdToge1xuMzogWycjZWRmOGIxJywnIzdmY2RiYicsJyMyYzdmYjgnXSxcbjQ6IFsnI2ZmZmZjYycsJyNhMWRhYjQnLCcjNDFiNmM0JywnIzIyNWVhOCddLFxuNTogWycjZmZmZmNjJywnI2ExZGFiNCcsJyM0MWI2YzQnLCcjMmM3ZmI4JywnIzI1MzQ5NCddLFxuNjogWycjZmZmZmNjJywnI2M3ZTliNCcsJyM3ZmNkYmInLCcjNDFiNmM0JywnIzJjN2ZiOCcsJyMyNTM0OTQnXSxcbjc6IFsnI2ZmZmZjYycsJyNjN2U5YjQnLCcjN2ZjZGJiJywnIzQxYjZjNCcsJyMxZDkxYzAnLCcjMjI1ZWE4JywnIzBjMmM4NCddLFxuODogWycjZmZmZmQ5JywnI2VkZjhiMScsJyNjN2U5YjQnLCcjN2ZjZGJiJywnIzQxYjZjNCcsJyMxZDkxYzAnLCcjMjI1ZWE4JywnIzBjMmM4NCddLFxuOTogWycjZmZmZmQ5JywnI2VkZjhiMScsJyNjN2U5YjQnLCcjN2ZjZGJiJywnIzQxYjZjNCcsJyMxZDkxYzAnLCcjMjI1ZWE4JywnIzI1MzQ5NCcsJyMwODFkNTgnXVxufSxHbkJ1OiB7XG4zOiBbJyNlMGYzZGInLCcjYThkZGI1JywnIzQzYTJjYSddLFxuNDogWycjZjBmOWU4JywnI2JhZTRiYycsJyM3YmNjYzQnLCcjMmI4Y2JlJ10sXG41OiBbJyNmMGY5ZTgnLCcjYmFlNGJjJywnIzdiY2NjNCcsJyM0M2EyY2EnLCcjMDg2OGFjJ10sXG42OiBbJyNmMGY5ZTgnLCcjY2NlYmM1JywnI2E4ZGRiNScsJyM3YmNjYzQnLCcjNDNhMmNhJywnIzA4NjhhYyddLFxuNzogWycjZjBmOWU4JywnI2NjZWJjNScsJyNhOGRkYjUnLCcjN2JjY2M0JywnIzRlYjNkMycsJyMyYjhjYmUnLCcjMDg1ODllJ10sXG44OiBbJyNmN2ZjZjAnLCcjZTBmM2RiJywnI2NjZWJjNScsJyNhOGRkYjUnLCcjN2JjY2M0JywnIzRlYjNkMycsJyMyYjhjYmUnLCcjMDg1ODllJ10sXG45OiBbJyNmN2ZjZjAnLCcjZTBmM2RiJywnI2NjZWJjNScsJyNhOGRkYjUnLCcjN2JjY2M0JywnIzRlYjNkMycsJyMyYjhjYmUnLCcjMDg2OGFjJywnIzA4NDA4MSddXG59LEJ1R246IHtcbjM6IFsnI2U1ZjVmOScsJyM5OWQ4YzknLCcjMmNhMjVmJ10sXG40OiBbJyNlZGY4ZmInLCcjYjJlMmUyJywnIzY2YzJhNCcsJyMyMzhiNDUnXSxcbjU6IFsnI2VkZjhmYicsJyNiMmUyZTInLCcjNjZjMmE0JywnIzJjYTI1ZicsJyMwMDZkMmMnXSxcbjY6IFsnI2VkZjhmYicsJyNjY2VjZTYnLCcjOTlkOGM5JywnIzY2YzJhNCcsJyMyY2EyNWYnLCcjMDA2ZDJjJ10sXG43OiBbJyNlZGY4ZmInLCcjY2NlY2U2JywnIzk5ZDhjOScsJyM2NmMyYTQnLCcjNDFhZTc2JywnIzIzOGI0NScsJyMwMDU4MjQnXSxcbjg6IFsnI2Y3ZmNmZCcsJyNlNWY1ZjknLCcjY2NlY2U2JywnIzk5ZDhjOScsJyM2NmMyYTQnLCcjNDFhZTc2JywnIzIzOGI0NScsJyMwMDU4MjQnXSxcbjk6IFsnI2Y3ZmNmZCcsJyNlNWY1ZjknLCcjY2NlY2U2JywnIzk5ZDhjOScsJyM2NmMyYTQnLCcjNDFhZTc2JywnIzIzOGI0NScsJyMwMDZkMmMnLCcjMDA0NDFiJ11cbn0sUHVCdUduOiB7XG4zOiBbJyNlY2UyZjAnLCcjYTZiZGRiJywnIzFjOTA5OSddLFxuNDogWycjZjZlZmY3JywnI2JkYzllMScsJyM2N2E5Y2YnLCcjMDI4MThhJ10sXG41OiBbJyNmNmVmZjcnLCcjYmRjOWUxJywnIzY3YTljZicsJyMxYzkwOTknLCcjMDE2YzU5J10sXG42OiBbJyNmNmVmZjcnLCcjZDBkMWU2JywnI2E2YmRkYicsJyM2N2E5Y2YnLCcjMWM5MDk5JywnIzAxNmM1OSddLFxuNzogWycjZjZlZmY3JywnI2QwZDFlNicsJyNhNmJkZGInLCcjNjdhOWNmJywnIzM2OTBjMCcsJyMwMjgxOGEnLCcjMDE2NDUwJ10sXG44OiBbJyNmZmY3ZmInLCcjZWNlMmYwJywnI2QwZDFlNicsJyNhNmJkZGInLCcjNjdhOWNmJywnIzM2OTBjMCcsJyMwMjgxOGEnLCcjMDE2NDUwJ10sXG45OiBbJyNmZmY3ZmInLCcjZWNlMmYwJywnI2QwZDFlNicsJyNhNmJkZGInLCcjNjdhOWNmJywnIzM2OTBjMCcsJyMwMjgxOGEnLCcjMDE2YzU5JywnIzAxNDYzNiddXG59LFB1QnU6IHtcbjM6IFsnI2VjZTdmMicsJyNhNmJkZGInLCcjMmI4Y2JlJ10sXG40OiBbJyNmMWVlZjYnLCcjYmRjOWUxJywnIzc0YTljZicsJyMwNTcwYjAnXSxcbjU6IFsnI2YxZWVmNicsJyNiZGM5ZTEnLCcjNzRhOWNmJywnIzJiOGNiZScsJyMwNDVhOGQnXSxcbjY6IFsnI2YxZWVmNicsJyNkMGQxZTYnLCcjYTZiZGRiJywnIzc0YTljZicsJyMyYjhjYmUnLCcjMDQ1YThkJ10sXG43OiBbJyNmMWVlZjYnLCcjZDBkMWU2JywnI2E2YmRkYicsJyM3NGE5Y2YnLCcjMzY5MGMwJywnIzA1NzBiMCcsJyMwMzRlN2InXSxcbjg6IFsnI2ZmZjdmYicsJyNlY2U3ZjInLCcjZDBkMWU2JywnI2E2YmRkYicsJyM3NGE5Y2YnLCcjMzY5MGMwJywnIzA1NzBiMCcsJyMwMzRlN2InXSxcbjk6IFsnI2ZmZjdmYicsJyNlY2U3ZjInLCcjZDBkMWU2JywnI2E2YmRkYicsJyM3NGE5Y2YnLCcjMzY5MGMwJywnIzA1NzBiMCcsJyMwNDVhOGQnLCcjMDIzODU4J11cbn0sQnVQdToge1xuMzogWycjZTBlY2Y0JywnIzllYmNkYScsJyM4ODU2YTcnXSxcbjQ6IFsnI2VkZjhmYicsJyNiM2NkZTMnLCcjOGM5NmM2JywnIzg4NDE5ZCddLFxuNTogWycjZWRmOGZiJywnI2IzY2RlMycsJyM4Yzk2YzYnLCcjODg1NmE3JywnIzgxMGY3YyddLFxuNjogWycjZWRmOGZiJywnI2JmZDNlNicsJyM5ZWJjZGEnLCcjOGM5NmM2JywnIzg4NTZhNycsJyM4MTBmN2MnXSxcbjc6IFsnI2VkZjhmYicsJyNiZmQzZTYnLCcjOWViY2RhJywnIzhjOTZjNicsJyM4YzZiYjEnLCcjODg0MTlkJywnIzZlMDE2YiddLFxuODogWycjZjdmY2ZkJywnI2UwZWNmNCcsJyNiZmQzZTYnLCcjOWViY2RhJywnIzhjOTZjNicsJyM4YzZiYjEnLCcjODg0MTlkJywnIzZlMDE2YiddLFxuOTogWycjZjdmY2ZkJywnI2UwZWNmNCcsJyNiZmQzZTYnLCcjOWViY2RhJywnIzhjOTZjNicsJyM4YzZiYjEnLCcjODg0MTlkJywnIzgxMGY3YycsJyM0ZDAwNGInXVxufSxSZFB1OiB7XG4zOiBbJyNmZGUwZGQnLCcjZmE5ZmI1JywnI2M1MWI4YSddLFxuNDogWycjZmVlYmUyJywnI2ZiYjRiOScsJyNmNzY4YTEnLCcjYWUwMTdlJ10sXG41OiBbJyNmZWViZTInLCcjZmJiNGI5JywnI2Y3NjhhMScsJyNjNTFiOGEnLCcjN2EwMTc3J10sXG42OiBbJyNmZWViZTInLCcjZmNjNWMwJywnI2ZhOWZiNScsJyNmNzY4YTEnLCcjYzUxYjhhJywnIzdhMDE3NyddLFxuNzogWycjZmVlYmUyJywnI2ZjYzVjMCcsJyNmYTlmYjUnLCcjZjc2OGExJywnI2RkMzQ5NycsJyNhZTAxN2UnLCcjN2EwMTc3J10sXG44OiBbJyNmZmY3ZjMnLCcjZmRlMGRkJywnI2ZjYzVjMCcsJyNmYTlmYjUnLCcjZjc2OGExJywnI2RkMzQ5NycsJyNhZTAxN2UnLCcjN2EwMTc3J10sXG45OiBbJyNmZmY3ZjMnLCcjZmRlMGRkJywnI2ZjYzVjMCcsJyNmYTlmYjUnLCcjZjc2OGExJywnI2RkMzQ5NycsJyNhZTAxN2UnLCcjN2EwMTc3JywnIzQ5MDA2YSddXG59LFB1UmQ6IHtcbjM6IFsnI2U3ZTFlZicsJyNjOTk0YzcnLCcjZGQxYzc3J10sXG40OiBbJyNmMWVlZjYnLCcjZDdiNWQ4JywnI2RmNjViMCcsJyNjZTEyNTYnXSxcbjU6IFsnI2YxZWVmNicsJyNkN2I1ZDgnLCcjZGY2NWIwJywnI2RkMWM3NycsJyM5ODAwNDMnXSxcbjY6IFsnI2YxZWVmNicsJyNkNGI5ZGEnLCcjYzk5NGM3JywnI2RmNjViMCcsJyNkZDFjNzcnLCcjOTgwMDQzJ10sXG43OiBbJyNmMWVlZjYnLCcjZDRiOWRhJywnI2M5OTRjNycsJyNkZjY1YjAnLCcjZTcyOThhJywnI2NlMTI1NicsJyM5MTAwM2YnXSxcbjg6IFsnI2Y3ZjRmOScsJyNlN2UxZWYnLCcjZDRiOWRhJywnI2M5OTRjNycsJyNkZjY1YjAnLCcjZTcyOThhJywnI2NlMTI1NicsJyM5MTAwM2YnXSxcbjk6IFsnI2Y3ZjRmOScsJyNlN2UxZWYnLCcjZDRiOWRhJywnI2M5OTRjNycsJyNkZjY1YjAnLCcjZTcyOThhJywnI2NlMTI1NicsJyM5ODAwNDMnLCcjNjcwMDFmJ11cbn0sT3JSZDoge1xuMzogWycjZmVlOGM4JywnI2ZkYmI4NCcsJyNlMzRhMzMnXSxcbjQ6IFsnI2ZlZjBkOScsJyNmZGNjOGEnLCcjZmM4ZDU5JywnI2Q3MzAxZiddLFxuNTogWycjZmVmMGQ5JywnI2ZkY2M4YScsJyNmYzhkNTknLCcjZTM0YTMzJywnI2IzMDAwMCddLFxuNjogWycjZmVmMGQ5JywnI2ZkZDQ5ZScsJyNmZGJiODQnLCcjZmM4ZDU5JywnI2UzNGEzMycsJyNiMzAwMDAnXSxcbjc6IFsnI2ZlZjBkOScsJyNmZGQ0OWUnLCcjZmRiYjg0JywnI2ZjOGQ1OScsJyNlZjY1NDgnLCcjZDczMDFmJywnIzk5MDAwMCddLFxuODogWycjZmZmN2VjJywnI2ZlZThjOCcsJyNmZGQ0OWUnLCcjZmRiYjg0JywnI2ZjOGQ1OScsJyNlZjY1NDgnLCcjZDczMDFmJywnIzk5MDAwMCddLFxuOTogWycjZmZmN2VjJywnI2ZlZThjOCcsJyNmZGQ0OWUnLCcjZmRiYjg0JywnI2ZjOGQ1OScsJyNlZjY1NDgnLCcjZDczMDFmJywnI2IzMDAwMCcsJyM3ZjAwMDAnXVxufSxZbE9yUmQ6IHtcbjM6IFsnI2ZmZWRhMCcsJyNmZWIyNGMnLCcjZjAzYjIwJ10sXG40OiBbJyNmZmZmYjInLCcjZmVjYzVjJywnI2ZkOGQzYycsJyNlMzFhMWMnXSxcbjU6IFsnI2ZmZmZiMicsJyNmZWNjNWMnLCcjZmQ4ZDNjJywnI2YwM2IyMCcsJyNiZDAwMjYnXSxcbjY6IFsnI2ZmZmZiMicsJyNmZWQ5NzYnLCcjZmViMjRjJywnI2ZkOGQzYycsJyNmMDNiMjAnLCcjYmQwMDI2J10sXG43OiBbJyNmZmZmYjInLCcjZmVkOTc2JywnI2ZlYjI0YycsJyNmZDhkM2MnLCcjZmM0ZTJhJywnI2UzMWExYycsJyNiMTAwMjYnXSxcbjg6IFsnI2ZmZmZjYycsJyNmZmVkYTAnLCcjZmVkOTc2JywnI2ZlYjI0YycsJyNmZDhkM2MnLCcjZmM0ZTJhJywnI2UzMWExYycsJyNiMTAwMjYnXSxcbjk6IFsnI2ZmZmZjYycsJyNmZmVkYTAnLCcjZmVkOTc2JywnI2ZlYjI0YycsJyNmZDhkM2MnLCcjZmM0ZTJhJywnI2UzMWExYycsJyNiZDAwMjYnLCcjODAwMDI2J11cbn0sWWxPckJyOiB7XG4zOiBbJyNmZmY3YmMnLCcjZmVjNDRmJywnI2Q5NWYwZSddLFxuNDogWycjZmZmZmQ0JywnI2ZlZDk4ZScsJyNmZTk5MjknLCcjY2M0YzAyJ10sXG41OiBbJyNmZmZmZDQnLCcjZmVkOThlJywnI2ZlOTkyOScsJyNkOTVmMGUnLCcjOTkzNDA0J10sXG42OiBbJyNmZmZmZDQnLCcjZmVlMzkxJywnI2ZlYzQ0ZicsJyNmZTk5MjknLCcjZDk1ZjBlJywnIzk5MzQwNCddLFxuNzogWycjZmZmZmQ0JywnI2ZlZTM5MScsJyNmZWM0NGYnLCcjZmU5OTI5JywnI2VjNzAxNCcsJyNjYzRjMDInLCcjOGMyZDA0J10sXG44OiBbJyNmZmZmZTUnLCcjZmZmN2JjJywnI2ZlZTM5MScsJyNmZWM0NGYnLCcjZmU5OTI5JywnI2VjNzAxNCcsJyNjYzRjMDInLCcjOGMyZDA0J10sXG45OiBbJyNmZmZmZTUnLCcjZmZmN2JjJywnI2ZlZTM5MScsJyNmZWM0NGYnLCcjZmU5OTI5JywnI2VjNzAxNCcsJyNjYzRjMDInLCcjOTkzNDA0JywnIzY2MjUwNiddXG59LFB1cnBsZXM6IHtcbjM6IFsnI2VmZWRmNScsJyNiY2JkZGMnLCcjNzU2YmIxJ10sXG40OiBbJyNmMmYwZjcnLCcjY2JjOWUyJywnIzllOWFjOCcsJyM2YTUxYTMnXSxcbjU6IFsnI2YyZjBmNycsJyNjYmM5ZTInLCcjOWU5YWM4JywnIzc1NmJiMScsJyM1NDI3OGYnXSxcbjY6IFsnI2YyZjBmNycsJyNkYWRhZWInLCcjYmNiZGRjJywnIzllOWFjOCcsJyM3NTZiYjEnLCcjNTQyNzhmJ10sXG43OiBbJyNmMmYwZjcnLCcjZGFkYWViJywnI2JjYmRkYycsJyM5ZTlhYzgnLCcjODA3ZGJhJywnIzZhNTFhMycsJyM0YTE0ODYnXSxcbjg6IFsnI2ZjZmJmZCcsJyNlZmVkZjUnLCcjZGFkYWViJywnI2JjYmRkYycsJyM5ZTlhYzgnLCcjODA3ZGJhJywnIzZhNTFhMycsJyM0YTE0ODYnXSxcbjk6IFsnI2ZjZmJmZCcsJyNlZmVkZjUnLCcjZGFkYWViJywnI2JjYmRkYycsJyM5ZTlhYzgnLCcjODA3ZGJhJywnIzZhNTFhMycsJyM1NDI3OGYnLCcjM2YwMDdkJ11cbn0sQmx1ZXM6IHtcbjM6IFsnI2RlZWJmNycsJyM5ZWNhZTEnLCcjMzE4MmJkJ10sXG40OiBbJyNlZmYzZmYnLCcjYmRkN2U3JywnIzZiYWVkNicsJyMyMTcxYjUnXSxcbjU6IFsnI2VmZjNmZicsJyNiZGQ3ZTcnLCcjNmJhZWQ2JywnIzMxODJiZCcsJyMwODUxOWMnXSxcbjY6IFsnI2VmZjNmZicsJyNjNmRiZWYnLCcjOWVjYWUxJywnIzZiYWVkNicsJyMzMTgyYmQnLCcjMDg1MTljJ10sXG43OiBbJyNlZmYzZmYnLCcjYzZkYmVmJywnIzllY2FlMScsJyM2YmFlZDYnLCcjNDI5MmM2JywnIzIxNzFiNScsJyMwODQ1OTQnXSxcbjg6IFsnI2Y3ZmJmZicsJyNkZWViZjcnLCcjYzZkYmVmJywnIzllY2FlMScsJyM2YmFlZDYnLCcjNDI5MmM2JywnIzIxNzFiNScsJyMwODQ1OTQnXSxcbjk6IFsnI2Y3ZmJmZicsJyNkZWViZjcnLCcjYzZkYmVmJywnIzllY2FlMScsJyM2YmFlZDYnLCcjNDI5MmM2JywnIzIxNzFiNScsJyMwODUxOWMnLCcjMDgzMDZiJ11cbn0sR3JlZW5zOiB7XG4zOiBbJyNlNWY1ZTAnLCcjYTFkOTliJywnIzMxYTM1NCddLFxuNDogWycjZWRmOGU5JywnI2JhZTRiMycsJyM3NGM0NzYnLCcjMjM4YjQ1J10sXG41OiBbJyNlZGY4ZTknLCcjYmFlNGIzJywnIzc0YzQ3NicsJyMzMWEzNTQnLCcjMDA2ZDJjJ10sXG42OiBbJyNlZGY4ZTknLCcjYzdlOWMwJywnI2ExZDk5YicsJyM3NGM0NzYnLCcjMzFhMzU0JywnIzAwNmQyYyddLFxuNzogWycjZWRmOGU5JywnI2M3ZTljMCcsJyNhMWQ5OWInLCcjNzRjNDc2JywnIzQxYWI1ZCcsJyMyMzhiNDUnLCcjMDA1YTMyJ10sXG44OiBbJyNmN2ZjZjUnLCcjZTVmNWUwJywnI2M3ZTljMCcsJyNhMWQ5OWInLCcjNzRjNDc2JywnIzQxYWI1ZCcsJyMyMzhiNDUnLCcjMDA1YTMyJ10sXG45OiBbJyNmN2ZjZjUnLCcjZTVmNWUwJywnI2M3ZTljMCcsJyNhMWQ5OWInLCcjNzRjNDc2JywnIzQxYWI1ZCcsJyMyMzhiNDUnLCcjMDA2ZDJjJywnIzAwNDQxYiddXG59LE9yYW5nZXM6IHtcbjM6IFsnI2ZlZTZjZScsJyNmZGFlNmInLCcjZTY1NTBkJ10sXG40OiBbJyNmZWVkZGUnLCcjZmRiZTg1JywnI2ZkOGQzYycsJyNkOTQ3MDEnXSxcbjU6IFsnI2ZlZWRkZScsJyNmZGJlODUnLCcjZmQ4ZDNjJywnI2U2NTUwZCcsJyNhNjM2MDMnXSxcbjY6IFsnI2ZlZWRkZScsJyNmZGQwYTInLCcjZmRhZTZiJywnI2ZkOGQzYycsJyNlNjU1MGQnLCcjYTYzNjAzJ10sXG43OiBbJyNmZWVkZGUnLCcjZmRkMGEyJywnI2ZkYWU2YicsJyNmZDhkM2MnLCcjZjE2OTEzJywnI2Q5NDgwMScsJyM4YzJkMDQnXSxcbjg6IFsnI2ZmZjVlYicsJyNmZWU2Y2UnLCcjZmRkMGEyJywnI2ZkYWU2YicsJyNmZDhkM2MnLCcjZjE2OTEzJywnI2Q5NDgwMScsJyM4YzJkMDQnXSxcbjk6IFsnI2ZmZjVlYicsJyNmZWU2Y2UnLCcjZmRkMGEyJywnI2ZkYWU2YicsJyNmZDhkM2MnLCcjZjE2OTEzJywnI2Q5NDgwMScsJyNhNjM2MDMnLCcjN2YyNzA0J11cbn0sUmVkczoge1xuMzogWycjZmVlMGQyJywnI2ZjOTI3MicsJyNkZTJkMjYnXSxcbjQ6IFsnI2ZlZTVkOScsJyNmY2FlOTEnLCcjZmI2YTRhJywnI2NiMTgxZCddLFxuNTogWycjZmVlNWQ5JywnI2ZjYWU5MScsJyNmYjZhNGEnLCcjZGUyZDI2JywnI2E1MGYxNSddLFxuNjogWycjZmVlNWQ5JywnI2ZjYmJhMScsJyNmYzkyNzInLCcjZmI2YTRhJywnI2RlMmQyNicsJyNhNTBmMTUnXSxcbjc6IFsnI2ZlZTVkOScsJyNmY2JiYTEnLCcjZmM5MjcyJywnI2ZiNmE0YScsJyNlZjNiMmMnLCcjY2IxODFkJywnIzk5MDAwZCddLFxuODogWycjZmZmNWYwJywnI2ZlZTBkMicsJyNmY2JiYTEnLCcjZmM5MjcyJywnI2ZiNmE0YScsJyNlZjNiMmMnLCcjY2IxODFkJywnIzk5MDAwZCddLFxuOTogWycjZmZmNWYwJywnI2ZlZTBkMicsJyNmY2JiYTEnLCcjZmM5MjcyJywnI2ZiNmE0YScsJyNlZjNiMmMnLCcjY2IxODFkJywnI2E1MGYxNScsJyM2NzAwMGQnXVxufSxHcmV5czoge1xuMzogWycjZjBmMGYwJywnI2JkYmRiZCcsJyM2MzYzNjMnXSxcbjQ6IFsnI2Y3ZjdmNycsJyNjY2NjY2MnLCcjOTY5Njk2JywnIzUyNTI1MiddLFxuNTogWycjZjdmN2Y3JywnI2NjY2NjYycsJyM5Njk2OTYnLCcjNjM2MzYzJywnIzI1MjUyNSddLFxuNjogWycjZjdmN2Y3JywnI2Q5ZDlkOScsJyNiZGJkYmQnLCcjOTY5Njk2JywnIzYzNjM2MycsJyMyNTI1MjUnXSxcbjc6IFsnI2Y3ZjdmNycsJyNkOWQ5ZDknLCcjYmRiZGJkJywnIzk2OTY5NicsJyM3MzczNzMnLCcjNTI1MjUyJywnIzI1MjUyNSddLFxuODogWycjZmZmZmZmJywnI2YwZjBmMCcsJyNkOWQ5ZDknLCcjYmRiZGJkJywnIzk2OTY5NicsJyM3MzczNzMnLCcjNTI1MjUyJywnIzI1MjUyNSddLFxuOTogWycjZmZmZmZmJywnI2YwZjBmMCcsJyNkOWQ5ZDknLCcjYmRiZGJkJywnIzk2OTY5NicsJyM3MzczNzMnLCcjNTI1MjUyJywnIzI1MjUyNScsJyMwMDAwMDAnXVxufSxQdU9yOiB7XG4zOiBbJyNmMWEzNDAnLCcjZjdmN2Y3JywnIzk5OGVjMyddLFxuNDogWycjZTY2MTAxJywnI2ZkYjg2MycsJyNiMmFiZDInLCcjNWUzYzk5J10sXG41OiBbJyNlNjYxMDEnLCcjZmRiODYzJywnI2Y3ZjdmNycsJyNiMmFiZDInLCcjNWUzYzk5J10sXG42OiBbJyNiMzU4MDYnLCcjZjFhMzQwJywnI2ZlZTBiNicsJyNkOGRhZWInLCcjOTk4ZWMzJywnIzU0Mjc4OCddLFxuNzogWycjYjM1ODA2JywnI2YxYTM0MCcsJyNmZWUwYjYnLCcjZjdmN2Y3JywnI2Q4ZGFlYicsJyM5OThlYzMnLCcjNTQyNzg4J10sXG44OiBbJyNiMzU4MDYnLCcjZTA4MjE0JywnI2ZkYjg2MycsJyNmZWUwYjYnLCcjZDhkYWViJywnI2IyYWJkMicsJyM4MDczYWMnLCcjNTQyNzg4J10sXG45OiBbJyNiMzU4MDYnLCcjZTA4MjE0JywnI2ZkYjg2MycsJyNmZWUwYjYnLCcjZjdmN2Y3JywnI2Q4ZGFlYicsJyNiMmFiZDInLCcjODA3M2FjJywnIzU0Mjc4OCddLFxuMTA6IFsnIzdmM2IwOCcsJyNiMzU4MDYnLCcjZTA4MjE0JywnI2ZkYjg2MycsJyNmZWUwYjYnLCcjZDhkYWViJywnI2IyYWJkMicsJyM4MDczYWMnLCcjNTQyNzg4JywnIzJkMDA0YiddLFxuMTE6IFsnIzdmM2IwOCcsJyNiMzU4MDYnLCcjZTA4MjE0JywnI2ZkYjg2MycsJyNmZWUwYjYnLCcjZjdmN2Y3JywnI2Q4ZGFlYicsJyNiMmFiZDInLCcjODA3M2FjJywnIzU0Mjc4OCcsJyMyZDAwNGInXVxufSxCckJHOiB7XG4zOiBbJyNkOGIzNjUnLCcjZjVmNWY1JywnIzVhYjRhYyddLFxuNDogWycjYTY2MTFhJywnI2RmYzI3ZCcsJyM4MGNkYzEnLCcjMDE4NTcxJ10sXG41OiBbJyNhNjYxMWEnLCcjZGZjMjdkJywnI2Y1ZjVmNScsJyM4MGNkYzEnLCcjMDE4NTcxJ10sXG42OiBbJyM4YzUxMGEnLCcjZDhiMzY1JywnI2Y2ZThjMycsJyNjN2VhZTUnLCcjNWFiNGFjJywnIzAxNjY1ZSddLFxuNzogWycjOGM1MTBhJywnI2Q4YjM2NScsJyNmNmU4YzMnLCcjZjVmNWY1JywnI2M3ZWFlNScsJyM1YWI0YWMnLCcjMDE2NjVlJ10sXG44OiBbJyM4YzUxMGEnLCcjYmY4MTJkJywnI2RmYzI3ZCcsJyNmNmU4YzMnLCcjYzdlYWU1JywnIzgwY2RjMScsJyMzNTk3OGYnLCcjMDE2NjVlJ10sXG45OiBbJyM4YzUxMGEnLCcjYmY4MTJkJywnI2RmYzI3ZCcsJyNmNmU4YzMnLCcjZjVmNWY1JywnI2M3ZWFlNScsJyM4MGNkYzEnLCcjMzU5NzhmJywnIzAxNjY1ZSddLFxuMTA6IFsnIzU0MzAwNScsJyM4YzUxMGEnLCcjYmY4MTJkJywnI2RmYzI3ZCcsJyNmNmU4YzMnLCcjYzdlYWU1JywnIzgwY2RjMScsJyMzNTk3OGYnLCcjMDE2NjVlJywnIzAwM2MzMCddLFxuMTE6IFsnIzU0MzAwNScsJyM4YzUxMGEnLCcjYmY4MTJkJywnI2RmYzI3ZCcsJyNmNmU4YzMnLCcjZjVmNWY1JywnI2M3ZWFlNScsJyM4MGNkYzEnLCcjMzU5NzhmJywnIzAxNjY1ZScsJyMwMDNjMzAnXVxufSxQUkduOiB7XG4zOiBbJyNhZjhkYzMnLCcjZjdmN2Y3JywnIzdmYmY3YiddLFxuNDogWycjN2IzMjk0JywnI2MyYTVjZicsJyNhNmRiYTAnLCcjMDA4ODM3J10sXG41OiBbJyM3YjMyOTQnLCcjYzJhNWNmJywnI2Y3ZjdmNycsJyNhNmRiYTAnLCcjMDA4ODM3J10sXG42OiBbJyM3NjJhODMnLCcjYWY4ZGMzJywnI2U3ZDRlOCcsJyNkOWYwZDMnLCcjN2ZiZjdiJywnIzFiNzgzNyddLFxuNzogWycjNzYyYTgzJywnI2FmOGRjMycsJyNlN2Q0ZTgnLCcjZjdmN2Y3JywnI2Q5ZjBkMycsJyM3ZmJmN2InLCcjMWI3ODM3J10sXG44OiBbJyM3NjJhODMnLCcjOTk3MGFiJywnI2MyYTVjZicsJyNlN2Q0ZTgnLCcjZDlmMGQzJywnI2E2ZGJhMCcsJyM1YWFlNjEnLCcjMWI3ODM3J10sXG45OiBbJyM3NjJhODMnLCcjOTk3MGFiJywnI2MyYTVjZicsJyNlN2Q0ZTgnLCcjZjdmN2Y3JywnI2Q5ZjBkMycsJyNhNmRiYTAnLCcjNWFhZTYxJywnIzFiNzgzNyddLFxuMTA6IFsnIzQwMDA0YicsJyM3NjJhODMnLCcjOTk3MGFiJywnI2MyYTVjZicsJyNlN2Q0ZTgnLCcjZDlmMGQzJywnI2E2ZGJhMCcsJyM1YWFlNjEnLCcjMWI3ODM3JywnIzAwNDQxYiddLFxuMTE6IFsnIzQwMDA0YicsJyM3NjJhODMnLCcjOTk3MGFiJywnI2MyYTVjZicsJyNlN2Q0ZTgnLCcjZjdmN2Y3JywnI2Q5ZjBkMycsJyNhNmRiYTAnLCcjNWFhZTYxJywnIzFiNzgzNycsJyMwMDQ0MWInXVxufSxQaVlHOiB7XG4zOiBbJyNlOWEzYzknLCcjZjdmN2Y3JywnI2ExZDc2YSddLFxuNDogWycjZDAxYzhiJywnI2YxYjZkYScsJyNiOGUxODYnLCcjNGRhYzI2J10sXG41OiBbJyNkMDFjOGInLCcjZjFiNmRhJywnI2Y3ZjdmNycsJyNiOGUxODYnLCcjNGRhYzI2J10sXG42OiBbJyNjNTFiN2QnLCcjZTlhM2M5JywnI2ZkZTBlZicsJyNlNmY1ZDAnLCcjYTFkNzZhJywnIzRkOTIyMSddLFxuNzogWycjYzUxYjdkJywnI2U5YTNjOScsJyNmZGUwZWYnLCcjZjdmN2Y3JywnI2U2ZjVkMCcsJyNhMWQ3NmEnLCcjNGQ5MjIxJ10sXG44OiBbJyNjNTFiN2QnLCcjZGU3N2FlJywnI2YxYjZkYScsJyNmZGUwZWYnLCcjZTZmNWQwJywnI2I4ZTE4NicsJyM3ZmJjNDEnLCcjNGQ5MjIxJ10sXG45OiBbJyNjNTFiN2QnLCcjZGU3N2FlJywnI2YxYjZkYScsJyNmZGUwZWYnLCcjZjdmN2Y3JywnI2U2ZjVkMCcsJyNiOGUxODYnLCcjN2ZiYzQxJywnIzRkOTIyMSddLFxuMTA6IFsnIzhlMDE1MicsJyNjNTFiN2QnLCcjZGU3N2FlJywnI2YxYjZkYScsJyNmZGUwZWYnLCcjZTZmNWQwJywnI2I4ZTE4NicsJyM3ZmJjNDEnLCcjNGQ5MjIxJywnIzI3NjQxOSddLFxuMTE6IFsnIzhlMDE1MicsJyNjNTFiN2QnLCcjZGU3N2FlJywnI2YxYjZkYScsJyNmZGUwZWYnLCcjZjdmN2Y3JywnI2U2ZjVkMCcsJyNiOGUxODYnLCcjN2ZiYzQxJywnIzRkOTIyMScsJyMyNzY0MTknXVxufSxSZEJ1OiB7XG4zOiBbJyNlZjhhNjInLCcjZjdmN2Y3JywnIzY3YTljZiddLFxuNDogWycjY2EwMDIwJywnI2Y0YTU4MicsJyM5MmM1ZGUnLCcjMDU3MWIwJ10sXG41OiBbJyNjYTAwMjAnLCcjZjRhNTgyJywnI2Y3ZjdmNycsJyM5MmM1ZGUnLCcjMDU3MWIwJ10sXG42OiBbJyNiMjE4MmInLCcjZWY4YTYyJywnI2ZkZGJjNycsJyNkMWU1ZjAnLCcjNjdhOWNmJywnIzIxNjZhYyddLFxuNzogWycjYjIxODJiJywnI2VmOGE2MicsJyNmZGRiYzcnLCcjZjdmN2Y3JywnI2QxZTVmMCcsJyM2N2E5Y2YnLCcjMjE2NmFjJ10sXG44OiBbJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZDFlNWYwJywnIzkyYzVkZScsJyM0MzkzYzMnLCcjMjE2NmFjJ10sXG45OiBbJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZjdmN2Y3JywnI2QxZTVmMCcsJyM5MmM1ZGUnLCcjNDM5M2MzJywnIzIxNjZhYyddLFxuMTA6IFsnIzY3MDAxZicsJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZDFlNWYwJywnIzkyYzVkZScsJyM0MzkzYzMnLCcjMjE2NmFjJywnIzA1MzA2MSddLFxuMTE6IFsnIzY3MDAxZicsJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZjdmN2Y3JywnI2QxZTVmMCcsJyM5MmM1ZGUnLCcjNDM5M2MzJywnIzIxNjZhYycsJyMwNTMwNjEnXVxufSxSZEd5OiB7XG4zOiBbJyNlZjhhNjInLCcjZmZmZmZmJywnIzk5OTk5OSddLFxuNDogWycjY2EwMDIwJywnI2Y0YTU4MicsJyNiYWJhYmEnLCcjNDA0MDQwJ10sXG41OiBbJyNjYTAwMjAnLCcjZjRhNTgyJywnI2ZmZmZmZicsJyNiYWJhYmEnLCcjNDA0MDQwJ10sXG42OiBbJyNiMjE4MmInLCcjZWY4YTYyJywnI2ZkZGJjNycsJyNlMGUwZTAnLCcjOTk5OTk5JywnIzRkNGQ0ZCddLFxuNzogWycjYjIxODJiJywnI2VmOGE2MicsJyNmZGRiYzcnLCcjZmZmZmZmJywnI2UwZTBlMCcsJyM5OTk5OTknLCcjNGQ0ZDRkJ10sXG44OiBbJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZTBlMGUwJywnI2JhYmFiYScsJyM4Nzg3ODcnLCcjNGQ0ZDRkJ10sXG45OiBbJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZmZmZmZmJywnI2UwZTBlMCcsJyNiYWJhYmEnLCcjODc4Nzg3JywnIzRkNGQ0ZCddLFxuMTA6IFsnIzY3MDAxZicsJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZTBlMGUwJywnI2JhYmFiYScsJyM4Nzg3ODcnLCcjNGQ0ZDRkJywnIzFhMWExYSddLFxuMTE6IFsnIzY3MDAxZicsJyNiMjE4MmInLCcjZDY2MDRkJywnI2Y0YTU4MicsJyNmZGRiYzcnLCcjZmZmZmZmJywnI2UwZTBlMCcsJyNiYWJhYmEnLCcjODc4Nzg3JywnIzRkNGQ0ZCcsJyMxYTFhMWEnXVxufSxSZFlsQnU6IHtcbjM6IFsnI2ZjOGQ1OScsJyNmZmZmYmYnLCcjOTFiZmRiJ10sXG40OiBbJyNkNzE5MWMnLCcjZmRhZTYxJywnI2FiZDllOScsJyMyYzdiYjYnXSxcbjU6IFsnI2Q3MTkxYycsJyNmZGFlNjEnLCcjZmZmZmJmJywnI2FiZDllOScsJyMyYzdiYjYnXSxcbjY6IFsnI2Q3MzAyNycsJyNmYzhkNTknLCcjZmVlMDkwJywnI2UwZjNmOCcsJyM5MWJmZGInLCcjNDU3NWI0J10sXG43OiBbJyNkNzMwMjcnLCcjZmM4ZDU5JywnI2ZlZTA5MCcsJyNmZmZmYmYnLCcjZTBmM2Y4JywnIzkxYmZkYicsJyM0NTc1YjQnXSxcbjg6IFsnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA5MCcsJyNlMGYzZjgnLCcjYWJkOWU5JywnIzc0YWRkMScsJyM0NTc1YjQnXSxcbjk6IFsnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA5MCcsJyNmZmZmYmYnLCcjZTBmM2Y4JywnI2FiZDllOScsJyM3NGFkZDEnLCcjNDU3NWI0J10sXG4xMDogWycjYTUwMDI2JywnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA5MCcsJyNlMGYzZjgnLCcjYWJkOWU5JywnIzc0YWRkMScsJyM0NTc1YjQnLCcjMzEzNjk1J10sXG4xMTogWycjYTUwMDI2JywnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA5MCcsJyNmZmZmYmYnLCcjZTBmM2Y4JywnI2FiZDllOScsJyM3NGFkZDEnLCcjNDU3NWI0JywnIzMxMzY5NSddXG59LFNwZWN0cmFsOiB7XG4zOiBbJyNmYzhkNTknLCcjZmZmZmJmJywnIzk5ZDU5NCddLFxuNDogWycjZDcxOTFjJywnI2ZkYWU2MScsJyNhYmRkYTQnLCcjMmI4M2JhJ10sXG41OiBbJyNkNzE5MWMnLCcjZmRhZTYxJywnI2ZmZmZiZicsJyNhYmRkYTQnLCcjMmI4M2JhJ10sXG42OiBbJyNkNTNlNGYnLCcjZmM4ZDU5JywnI2ZlZTA4YicsJyNlNmY1OTgnLCcjOTlkNTk0JywnIzMyODhiZCddLFxuNzogWycjZDUzZTRmJywnI2ZjOGQ1OScsJyNmZWUwOGInLCcjZmZmZmJmJywnI2U2ZjU5OCcsJyM5OWQ1OTQnLCcjMzI4OGJkJ10sXG44OiBbJyNkNTNlNGYnLCcjZjQ2ZDQzJywnI2ZkYWU2MScsJyNmZWUwOGInLCcjZTZmNTk4JywnI2FiZGRhNCcsJyM2NmMyYTUnLCcjMzI4OGJkJ10sXG45OiBbJyNkNTNlNGYnLCcjZjQ2ZDQzJywnI2ZkYWU2MScsJyNmZWUwOGInLCcjZmZmZmJmJywnI2U2ZjU5OCcsJyNhYmRkYTQnLCcjNjZjMmE1JywnIzMyODhiZCddLFxuMTA6IFsnIzllMDE0MicsJyNkNTNlNGYnLCcjZjQ2ZDQzJywnI2ZkYWU2MScsJyNmZWUwOGInLCcjZTZmNTk4JywnI2FiZGRhNCcsJyM2NmMyYTUnLCcjMzI4OGJkJywnIzVlNGZhMiddLFxuMTE6IFsnIzllMDE0MicsJyNkNTNlNGYnLCcjZjQ2ZDQzJywnI2ZkYWU2MScsJyNmZWUwOGInLCcjZmZmZmJmJywnI2U2ZjU5OCcsJyNhYmRkYTQnLCcjNjZjMmE1JywnIzMyODhiZCcsJyM1ZTRmYTInXVxufSxSZFlsR246IHtcbjM6IFsnI2ZjOGQ1OScsJyNmZmZmYmYnLCcjOTFjZjYwJ10sXG40OiBbJyNkNzE5MWMnLCcjZmRhZTYxJywnI2E2ZDk2YScsJyMxYTk2NDEnXSxcbjU6IFsnI2Q3MTkxYycsJyNmZGFlNjEnLCcjZmZmZmJmJywnI2E2ZDk2YScsJyMxYTk2NDEnXSxcbjY6IFsnI2Q3MzAyNycsJyNmYzhkNTknLCcjZmVlMDhiJywnI2Q5ZWY4YicsJyM5MWNmNjAnLCcjMWE5ODUwJ10sXG43OiBbJyNkNzMwMjcnLCcjZmM4ZDU5JywnI2ZlZTA4YicsJyNmZmZmYmYnLCcjZDllZjhiJywnIzkxY2Y2MCcsJyMxYTk4NTAnXSxcbjg6IFsnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA4YicsJyNkOWVmOGInLCcjYTZkOTZhJywnIzY2YmQ2MycsJyMxYTk4NTAnXSxcbjk6IFsnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA4YicsJyNmZmZmYmYnLCcjZDllZjhiJywnI2E2ZDk2YScsJyM2NmJkNjMnLCcjMWE5ODUwJ10sXG4xMDogWycjYTUwMDI2JywnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA4YicsJyNkOWVmOGInLCcjYTZkOTZhJywnIzY2YmQ2MycsJyMxYTk4NTAnLCcjMDA2ODM3J10sXG4xMTogWycjYTUwMDI2JywnI2Q3MzAyNycsJyNmNDZkNDMnLCcjZmRhZTYxJywnI2ZlZTA4YicsJyNmZmZmYmYnLCcjZDllZjhiJywnI2E2ZDk2YScsJyM2NmJkNjMnLCcjMWE5ODUwJywnIzAwNjgzNyddXG59LEFjY2VudDoge1xuMzogWycjN2ZjOTdmJywnI2JlYWVkNCcsJyNmZGMwODYnXSxcbjQ6IFsnIzdmYzk3ZicsJyNiZWFlZDQnLCcjZmRjMDg2JywnI2ZmZmY5OSddLFxuNTogWycjN2ZjOTdmJywnI2JlYWVkNCcsJyNmZGMwODYnLCcjZmZmZjk5JywnIzM4NmNiMCddLFxuNjogWycjN2ZjOTdmJywnI2JlYWVkNCcsJyNmZGMwODYnLCcjZmZmZjk5JywnIzM4NmNiMCcsJyNmMDAyN2YnXSxcbjc6IFsnIzdmYzk3ZicsJyNiZWFlZDQnLCcjZmRjMDg2JywnI2ZmZmY5OScsJyMzODZjYjAnLCcjZjAwMjdmJywnI2JmNWIxNyddLFxuODogWycjN2ZjOTdmJywnI2JlYWVkNCcsJyNmZGMwODYnLCcjZmZmZjk5JywnIzM4NmNiMCcsJyNmMDAyN2YnLCcjYmY1YjE3JywnIzY2NjY2NiddXG59LERhcmsyOiB7XG4zOiBbJyMxYjllNzcnLCcjZDk1ZjAyJywnIzc1NzBiMyddLFxuNDogWycjMWI5ZTc3JywnI2Q5NWYwMicsJyM3NTcwYjMnLCcjZTcyOThhJ10sXG41OiBbJyMxYjllNzcnLCcjZDk1ZjAyJywnIzc1NzBiMycsJyNlNzI5OGEnLCcjNjZhNjFlJ10sXG42OiBbJyMxYjllNzcnLCcjZDk1ZjAyJywnIzc1NzBiMycsJyNlNzI5OGEnLCcjNjZhNjFlJywnI2U2YWIwMiddLFxuNzogWycjMWI5ZTc3JywnI2Q5NWYwMicsJyM3NTcwYjMnLCcjZTcyOThhJywnIzY2YTYxZScsJyNlNmFiMDInLCcjYTY3NjFkJ10sXG44OiBbJyMxYjllNzcnLCcjZDk1ZjAyJywnIzc1NzBiMycsJyNlNzI5OGEnLCcjNjZhNjFlJywnI2U2YWIwMicsJyNhNjc2MWQnLCcjNjY2NjY2J11cbn0sUGFpcmVkOiB7XG4zOiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YSddLFxuNDogWycjYTZjZWUzJywnIzFmNzhiNCcsJyNiMmRmOGEnLCcjMzNhMDJjJ10sXG41OiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YScsJyMzM2EwMmMnLCcjZmI5YTk5J10sXG42OiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YScsJyMzM2EwMmMnLCcjZmI5YTk5JywnI2UzMWExYyddLFxuNzogWycjYTZjZWUzJywnIzFmNzhiNCcsJyNiMmRmOGEnLCcjMzNhMDJjJywnI2ZiOWE5OScsJyNlMzFhMWMnLCcjZmRiZjZmJ10sXG44OiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YScsJyMzM2EwMmMnLCcjZmI5YTk5JywnI2UzMWExYycsJyNmZGJmNmYnLCcjZmY3ZjAwJ10sXG45OiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YScsJyMzM2EwMmMnLCcjZmI5YTk5JywnI2UzMWExYycsJyNmZGJmNmYnLCcjZmY3ZjAwJywnI2NhYjJkNiddLFxuMTA6IFsnI2E2Y2VlMycsJyMxZjc4YjQnLCcjYjJkZjhhJywnIzMzYTAyYycsJyNmYjlhOTknLCcjZTMxYTFjJywnI2ZkYmY2ZicsJyNmZjdmMDAnLCcjY2FiMmQ2JywnIzZhM2Q5YSddLFxuMTE6IFsnI2E2Y2VlMycsJyMxZjc4YjQnLCcjYjJkZjhhJywnIzMzYTAyYycsJyNmYjlhOTknLCcjZTMxYTFjJywnI2ZkYmY2ZicsJyNmZjdmMDAnLCcjY2FiMmQ2JywnIzZhM2Q5YScsJyNmZmZmOTknXSxcbjEyOiBbJyNhNmNlZTMnLCcjMWY3OGI0JywnI2IyZGY4YScsJyMzM2EwMmMnLCcjZmI5YTk5JywnI2UzMWExYycsJyNmZGJmNmYnLCcjZmY3ZjAwJywnI2NhYjJkNicsJyM2YTNkOWEnLCcjZmZmZjk5JywnI2IxNTkyOCddXG59LFBhc3RlbDE6IHtcbjM6IFsnI2ZiYjRhZScsJyNiM2NkZTMnLCcjY2NlYmM1J10sXG40OiBbJyNmYmI0YWUnLCcjYjNjZGUzJywnI2NjZWJjNScsJyNkZWNiZTQnXSxcbjU6IFsnI2ZiYjRhZScsJyNiM2NkZTMnLCcjY2NlYmM1JywnI2RlY2JlNCcsJyNmZWQ5YTYnXSxcbjY6IFsnI2ZiYjRhZScsJyNiM2NkZTMnLCcjY2NlYmM1JywnI2RlY2JlNCcsJyNmZWQ5YTYnLCcjZmZmZmNjJ10sXG43OiBbJyNmYmI0YWUnLCcjYjNjZGUzJywnI2NjZWJjNScsJyNkZWNiZTQnLCcjZmVkOWE2JywnI2ZmZmZjYycsJyNlNWQ4YmQnXSxcbjg6IFsnI2ZiYjRhZScsJyNiM2NkZTMnLCcjY2NlYmM1JywnI2RlY2JlNCcsJyNmZWQ5YTYnLCcjZmZmZmNjJywnI2U1ZDhiZCcsJyNmZGRhZWMnXSxcbjk6IFsnI2ZiYjRhZScsJyNiM2NkZTMnLCcjY2NlYmM1JywnI2RlY2JlNCcsJyNmZWQ5YTYnLCcjZmZmZmNjJywnI2U1ZDhiZCcsJyNmZGRhZWMnLCcjZjJmMmYyJ11cbn0sUGFzdGVsMjoge1xuMzogWycjYjNlMmNkJywnI2ZkY2RhYycsJyNjYmQ1ZTgnXSxcbjQ6IFsnI2IzZTJjZCcsJyNmZGNkYWMnLCcjY2JkNWU4JywnI2Y0Y2FlNCddLFxuNTogWycjYjNlMmNkJywnI2ZkY2RhYycsJyNjYmQ1ZTgnLCcjZjRjYWU0JywnI2U2ZjVjOSddLFxuNjogWycjYjNlMmNkJywnI2ZkY2RhYycsJyNjYmQ1ZTgnLCcjZjRjYWU0JywnI2U2ZjVjOScsJyNmZmYyYWUnXSxcbjc6IFsnI2IzZTJjZCcsJyNmZGNkYWMnLCcjY2JkNWU4JywnI2Y0Y2FlNCcsJyNlNmY1YzknLCcjZmZmMmFlJywnI2YxZTJjYyddLFxuODogWycjYjNlMmNkJywnI2ZkY2RhYycsJyNjYmQ1ZTgnLCcjZjRjYWU0JywnI2U2ZjVjOScsJyNmZmYyYWUnLCcjZjFlMmNjJywnI2NjY2NjYyddXG59LFNldDE6IHtcbjM6IFsnI2U0MWExYycsJyMzNzdlYjgnLCcjNGRhZjRhJ10sXG40OiBbJyNlNDFhMWMnLCcjMzc3ZWI4JywnIzRkYWY0YScsJyM5ODRlYTMnXSxcbjU6IFsnI2U0MWExYycsJyMzNzdlYjgnLCcjNGRhZjRhJywnIzk4NGVhMycsJyNmZjdmMDAnXSxcbjY6IFsnI2U0MWExYycsJyMzNzdlYjgnLCcjNGRhZjRhJywnIzk4NGVhMycsJyNmZjdmMDAnLCcjZmZmZjMzJ10sXG43OiBbJyNlNDFhMWMnLCcjMzc3ZWI4JywnIzRkYWY0YScsJyM5ODRlYTMnLCcjZmY3ZjAwJywnI2ZmZmYzMycsJyNhNjU2MjgnXSxcbjg6IFsnI2U0MWExYycsJyMzNzdlYjgnLCcjNGRhZjRhJywnIzk4NGVhMycsJyNmZjdmMDAnLCcjZmZmZjMzJywnI2E2NTYyOCcsJyNmNzgxYmYnXSxcbjk6IFsnI2U0MWExYycsJyMzNzdlYjgnLCcjNGRhZjRhJywnIzk4NGVhMycsJyNmZjdmMDAnLCcjZmZmZjMzJywnI2E2NTYyOCcsJyNmNzgxYmYnLCcjOTk5OTk5J11cbn0sU2V0Mjoge1xuMzogWycjNjZjMmE1JywnI2ZjOGQ2MicsJyM4ZGEwY2InXSxcbjQ6IFsnIzY2YzJhNScsJyNmYzhkNjInLCcjOGRhMGNiJywnI2U3OGFjMyddLFxuNTogWycjNjZjMmE1JywnI2ZjOGQ2MicsJyM4ZGEwY2InLCcjZTc4YWMzJywnI2E2ZDg1NCddLFxuNjogWycjNjZjMmE1JywnI2ZjOGQ2MicsJyM4ZGEwY2InLCcjZTc4YWMzJywnI2E2ZDg1NCcsJyNmZmQ5MmYnXSxcbjc6IFsnIzY2YzJhNScsJyNmYzhkNjInLCcjOGRhMGNiJywnI2U3OGFjMycsJyNhNmQ4NTQnLCcjZmZkOTJmJywnI2U1YzQ5NCddLFxuODogWycjNjZjMmE1JywnI2ZjOGQ2MicsJyM4ZGEwY2InLCcjZTc4YWMzJywnI2E2ZDg1NCcsJyNmZmQ5MmYnLCcjZTVjNDk0JywnI2IzYjNiMyddXG59LFNldDM6IHtcbjM6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJ10sXG40OiBbJyM4ZGQzYzcnLCcjZmZmZmIzJywnI2JlYmFkYScsJyNmYjgwNzInXSxcbjU6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJywnI2ZiODA3MicsJyM4MGIxZDMnXSxcbjY6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJywnI2ZiODA3MicsJyM4MGIxZDMnLCcjZmRiNDYyJ10sXG43OiBbJyM4ZGQzYzcnLCcjZmZmZmIzJywnI2JlYmFkYScsJyNmYjgwNzInLCcjODBiMWQzJywnI2ZkYjQ2MicsJyNiM2RlNjknXSxcbjg6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJywnI2ZiODA3MicsJyM4MGIxZDMnLCcjZmRiNDYyJywnI2IzZGU2OScsJyNmY2NkZTUnXSxcbjk6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJywnI2ZiODA3MicsJyM4MGIxZDMnLCcjZmRiNDYyJywnI2IzZGU2OScsJyNmY2NkZTUnLCcjZDlkOWQ5J10sXG4xMDogWycjOGRkM2M3JywnI2ZmZmZiMycsJyNiZWJhZGEnLCcjZmI4MDcyJywnIzgwYjFkMycsJyNmZGI0NjInLCcjYjNkZTY5JywnI2ZjY2RlNScsJyNkOWQ5ZDknLCcjYmM4MGJkJ10sXG4xMTogWycjOGRkM2M3JywnI2ZmZmZiMycsJyNiZWJhZGEnLCcjZmI4MDcyJywnIzgwYjFkMycsJyNmZGI0NjInLCcjYjNkZTY5JywnI2ZjY2RlNScsJyNkOWQ5ZDknLCcjYmM4MGJkJywnI2NjZWJjNSddLFxuMTI6IFsnIzhkZDNjNycsJyNmZmZmYjMnLCcjYmViYWRhJywnI2ZiODA3MicsJyM4MGIxZDMnLCcjZmRiNDYyJywnI2IzZGU2OScsJyNmY2NkZTUnLCcjZDlkOWQ5JywnI2JjODBiZCcsJyNjY2ViYzUnLCcjZmZlZDZmJ11cbn19OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkM19jbGFzcyhjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHtcbiAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxudmFyIGQzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hcDogcmVxdWlyZSgnLi9tYXAnKVxufTtcblxuZDMuY29sb3IgPSBkM19jb2xvcjtcblxuZnVuY3Rpb24gZDNfY29sb3IoKSB7fVxuZDNfY29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJnYigpICsgJyc7XG59O1xuZDMuaHNsID0gZDNfaHNsO1xuXG5mdW5jdGlvbiBkM19oc2woaCwgcywgbCkge1xuXG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaHNsID8gdm9pZCh0aGlzLmggPSAraCwgdGhpcy5zID0gK3MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPFxuICAgIDIgPyBoIGluc3RhbmNlb2YgZDNfaHNsID8gbmV3IGQzX2hzbChoLmgsIGgucywgaC5sKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgaCwgZDNfcmdiX2hzbCxcbiAgICAgIGQzX2hzbCkgOiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xufVxudmFyIGQzX2hzbFByb3RvdHlwZSA9IGQzX2hzbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbmQzX2hzbFByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sIC8gayk7XG59O1xuZDNfaHNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgayAqIHRoaXMubCk7XG59O1xuZDNfaHNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZDNfaHNsX3JnYih0aGlzLmgsIHRoaXMucywgdGhpcy5sKTtcbn07XG5cbmZ1bmN0aW9uIGQzX2hzbF9yZ2IoaCwgcywgbCkge1xuICB2YXIgbTEsIG0yO1xuICBoID0gaXNOYU4oaCkgPyAwIDogKGggJT0gMzYwKSA8IDAgPyBoICsgMzYwIDogaDtcbiAgcyA9IGlzTmFOKHMpID8gMCA6IHMgPCAwID8gMCA6IHMgPiAxID8gMSA6IHM7XG4gIGwgPSBsIDwgMCA/IDAgOiBsID4gMSA/IDEgOiBsO1xuICBtMiA9IGwgPD0gLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIG0xID0gMiAqIGwgLSBtMjtcblxuICBmdW5jdGlvbiB2KGgpIHtcbiAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7XG4gICAgZWxzZSBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgIGlmIChoIDwgNjApIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggLyA2MDtcbiAgICBpZiAoaCA8IDE4MCkgcmV0dXJuIG0yO1xuICAgIGlmIChoIDwgMjQwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MDtcbiAgICByZXR1cm4gbTE7XG4gIH1cblxuICBmdW5jdGlvbiB2dihoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodihoKSAqIDI1NSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBkM19yZ2IodnYoaCArIDEyMCksIHZ2KGgpLCB2dihoIC0gMTIwKSk7XG59XG5kMy5oY2wgPSBkM19oY2w7XG5cbmZ1bmN0aW9uIGQzX2hjbChoLCBjLCBsKSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaGNsID8gdm9pZCh0aGlzLmggPSAraCwgdGhpcy5jID0gK2MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPFxuICAgIDIgPyBoIGluc3RhbmNlb2YgZDNfaGNsID8gbmV3IGQzX2hjbChoLmgsIGguYywgaC5sKSA6IGggaW5zdGFuY2VvZiBkM19sYWIgPyBkM19sYWJfaGNsKGgubCxcbiAgICAgIGguYSwgaC5iKSA6IGQzX2xhYl9oY2woKGggPSBkM19yZ2JfbGFiKChoID0gZDMucmdiKGgpKS5yLCBoLmcsIGguYikpLmwsIGguYSwgaC5iKSA6IG5ldyBkM19oY2woXG4gICAgICBoLCBjLCBsKTtcbn1cbnZhciBkM19oY2xQcm90b3R5cGUgPSBkM19oY2wucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG5kM19oY2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbn07XG5kM19oY2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xufTtcbmQzX2hjbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGQzX2hjbF9sYWIodGhpcy5oLCB0aGlzLmMsIHRoaXMubCkucmdiKCk7XG59O1xuXG5mdW5jdGlvbiBkM19oY2xfbGFiKGgsIGMsIGwpIHtcbiAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgaWYgKGlzTmFOKGMpKSBjID0gMDtcbiAgcmV0dXJuIG5ldyBkM19sYWIobCwgTWF0aC5jb3MoaCAqPSBkM19yYWRpYW5zKSAqIGMsIE1hdGguc2luKGgpICogYyk7XG59XG5kMy5sYWIgPSBkM19sYWI7XG5cbmZ1bmN0aW9uIGQzX2xhYihsLCBhLCBiKSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfbGFiID8gdm9pZCh0aGlzLmwgPSArbCwgdGhpcy5hID0gK2EsIHRoaXMuYiA9ICtiKSA6IGFyZ3VtZW50cy5sZW5ndGggPFxuICAgIDIgPyBsIGluc3RhbmNlb2YgZDNfbGFiID8gbmV3IGQzX2xhYihsLmwsIGwuYSwgbC5iKSA6IGwgaW5zdGFuY2VvZiBkM19oY2wgPyBkM19oY2xfbGFiKGwuaCxcbiAgICAgIGwuYywgbC5sKSA6IGQzX3JnYl9sYWIoKGwgPSBkM19yZ2IobCkpLnIsIGwuZywgbC5iKSA6IG5ldyBkM19sYWIobCwgYSwgYik7XG59XG52YXIgZDNfbGFiX0sgPSAxODtcbnZhciBkM19sYWJfWCA9IC45NTA0NyxcbiAgZDNfbGFiX1kgPSAxLFxuICBkM19sYWJfWiA9IDEuMDg4ODM7XG52YXIgZDNfbGFiUHJvdG90eXBlID0gZDNfbGFiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuZDNfbGFiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXNcbiAgICAuYik7XG59O1xuZDNfbGFiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbn07XG5kM19sYWJQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBkM19sYWJfcmdiKHRoaXMubCwgdGhpcy5hLCB0aGlzLmIpO1xufTtcblxuZDMubGFiX3JnYiA9IGZ1bmN0aW9uIGQzX2xhYl9yZ2IobCwgYSwgYikge1xuICB2YXIgeSA9IChsICsgMTYpIC8gMTE2LFxuICAgIHggPSB5ICsgYSAvIDUwMCxcbiAgICB6ID0geSAtIGIgLyAyMDA7XG4gIHggPSBkM19sYWJfeHl6KHgpICogZDNfbGFiX1g7XG4gIHkgPSBkM19sYWJfeHl6KHkpICogZDNfbGFiX1k7XG4gIHogPSBkM19sYWJfeHl6KHopICogZDNfbGFiX1o7XG4gIHJldHVybiBuZXcgZDNfcmdiKGQzX3h5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAuNDk4NTMxNCAqIHopLCBkM194eXpfcmdiKC0uOTY5MjY2ICpcbiAgICB4ICsgMS44NzYwMTA4ICogeSArIC4wNDE1NTYgKiB6KSwgZDNfeHl6X3JnYiguMDU1NjQzNCAqIHggLSAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKlxuICAgIHopKTtcbn1cblxuZnVuY3Rpb24gZDNfbGFiX2hjbChsLCBhLCBiKSB7XG4gIHJldHVybiBsID4gMCA/IG5ldyBkM19oY2woTWF0aC5hdGFuMihiLCBhKSAqIGQzX2RlZ3JlZXMsIE1hdGguc3FydChhICogYSArIGIgKiBiKSwgbCkgOiBuZXcgZDNfaGNsKFxuICAgIE5hTiwgTmFOLCBsKTtcbn1cblxuZnVuY3Rpb24gZDNfbGFiX3h5eih4KSB7XG4gIHJldHVybiB4ID4gLjIwNjg5MzAzNCA/IHggKiB4ICogeCA6ICh4IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xufVxuXG5mdW5jdGlvbiBkM194eXpfbGFiKHgpIHtcbiAgcmV0dXJuIHggPiAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcwMzcgKiB4ICsgNCAvIDI5O1xufVxuXG5mdW5jdGlvbiBkM194eXpfcmdiKHIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoMjU1ICogKHIgPD0gLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBNYXRoLnBvdyhyLCAxIC8gMi40KSAtIC4wNTUpKTtcbn1cbmQzLnJnYiA9IGQzX3JnYjtcblxuZnVuY3Rpb24gZDNfcmdiKHIsIGcsIGIpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19yZ2IgPyB2b2lkKHRoaXMuciA9IH5+ciwgdGhpcy5nID0gfn5nLCB0aGlzLmIgPSB+fmIpIDogYXJndW1lbnRzLmxlbmd0aCA8XG4gICAgMiA/IHIgaW5zdGFuY2VvZiBkM19yZ2IgPyBuZXcgZDNfcmdiKHIuciwgci5nLCByLmIpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyByLCBkM19yZ2IsXG4gICAgICBkM19oc2xfcmdiKSA6IG5ldyBkM19yZ2IociwgZywgYik7XG59XG5cbmZ1bmN0aW9uIGQzX3JnYk51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gbmV3IGQzX3JnYih2YWx1ZSA+PiAxNiwgdmFsdWUgPj4gOCAmIDI1NSwgdmFsdWUgJiAyNTUpO1xufVxuXG5mdW5jdGlvbiBkM19yZ2JTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGQzX3JnYk51bWJlcih2YWx1ZSkgKyBcIlwiO1xufVxudmFyIGQzX3JnYlByb3RvdHlwZSA9IGQzX3JnYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbmQzX3JnYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICB2YXIgciA9IHRoaXMucixcbiAgICBnID0gdGhpcy5nLFxuICAgIGIgPSB0aGlzLmIsXG4gICAgaSA9IDMwO1xuICBpZiAoIXIgJiYgIWcgJiYgIWIpIHJldHVybiBuZXcgZDNfcmdiKGksIGksIGkpO1xuICBpZiAociAmJiByIDwgaSkgciA9IGk7XG4gIGlmIChnICYmIGcgPCBpKSBnID0gaTtcbiAgaWYgKGIgJiYgYiA8IGkpIGIgPSBpO1xuICByZXR1cm4gbmV3IGQzX3JnYihNYXRoLm1pbigyNTUsIHIgLyBrKSwgTWF0aC5taW4oMjU1LCBnIC8gayksIE1hdGgubWluKDI1NSwgYiAvIGspKTtcbn07XG5kM19yZ2JQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gIHJldHVybiBuZXcgZDNfcmdiKGsgKiB0aGlzLnIsIGsgKiB0aGlzLmcsIGsgKiB0aGlzLmIpO1xufTtcbmQzX3JnYlByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGQzX3JnYl9oc2wodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG59O1xuZDNfcmdiUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgodGhpcy5yKSArIGQzX3JnYl9oZXgodGhpcy5nKSArIGQzX3JnYl9oZXgodGhpcy5iKTtcbn07XG5cbmZ1bmN0aW9uIGQzX3JnYl9oZXgodikge1xuICByZXR1cm4gdiA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCB2KS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHYpLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gZDNfcmdiX3BhcnNlKGZvcm1hdCwgcmdiLCBoc2wpIHtcbiAgdmFyIHIgPSAwLFxuICAgIGcgPSAwLFxuICAgIGIgPSAwLFxuICAgIG0xLCBtMiwgY29sb3I7XG4gIG0xID0gLyhbYS16XSspXFwoKC4qKVxcKS9pLmV4ZWMoZm9ybWF0KTtcbiAgaWYgKG0xKSB7XG4gICAgbTIgPSBtMVsyXS5zcGxpdChcIixcIik7XG4gICAgc3dpdGNoIChtMVsxXSkge1xuICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGhzbChwYXJzZUZsb2F0KG0yWzBdKSwgcGFyc2VGbG9hdChtMlsxXSkgLyAxMDAsIHBhcnNlRmxvYXQobTJbMl0pIC8gMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcmdiKGQzX3JnYl9wYXJzZU51bWJlcihtMlswXSksIGQzX3JnYl9wYXJzZU51bWJlcihtMlsxXSksIGQzX3JnYl9wYXJzZU51bWJlcihcbiAgICAgICAgICAgIG0yWzJdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yID0gZDNfcmdiX25hbWVzLmdldChmb3JtYXQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gcmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICB9XG4gIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQuY2hhckF0KDApID09PSBcIiNcIiAmJiAhaXNOYU4oY29sb3IgPSBwYXJzZUludChmb3JtYXQuc2xpY2UoMSksIDE2KSkpIHtcbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgciA9IChjb2xvciAmIDM4NDApID4+IDQ7XG4gICAgICByID0gciA+PiA0IHwgcjtcbiAgICAgIGcgPSBjb2xvciAmIDI0MDtcbiAgICAgIGcgPSBnID4+IDQgfCBnO1xuICAgICAgYiA9IGNvbG9yICYgMTU7XG4gICAgICBiID0gYiA8PCA0IHwgYjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdC5sZW5ndGggPT09IDcpIHtcbiAgICAgIHIgPSAoY29sb3IgJiAxNjcxMTY4MCkgPj4gMTY7XG4gICAgICBnID0gKGNvbG9yICYgNjUyODApID4+IDg7XG4gICAgICBiID0gY29sb3IgJiAyNTU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZ2IociwgZywgYik7XG59XG5cbmZ1bmN0aW9uIGQzX3JnYl9oc2wociwgZywgYikge1xuICB2YXIgbWluID0gTWF0aC5taW4ociAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSksXG4gICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgZCA9IG1heCAtIG1pbixcbiAgICBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAoZCkge1xuICAgIHMgPSBsIDwgLjUgPyBkIC8gKG1heCArIG1pbikgOiBkIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgIGlmIChyID09IG1heCkgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgIGVsc2UgaWYgKGcgPT0gbWF4KSBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIGggPSBOYU47XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBkM19oc2woaCwgcywgbCk7XG59XG5cbmZ1bmN0aW9uIGQzX3JnYl9sYWIociwgZywgYikge1xuICByID0gZDNfcmdiX3h5eihyKTtcbiAgZyA9IGQzX3JnYl94eXooZyk7XG4gIGIgPSBkM19yZ2JfeHl6KGIpO1xuICB2YXIgeCA9IGQzX3h5el9sYWIoKC40MTI0NTY0ICogciArIC4zNTc1NzYxICogZyArIC4xODA0Mzc1ICogYikgLyBkM19sYWJfWCksXG4gICAgeSA9IGQzX3h5el9sYWIoKC4yMTI2NzI5ICogciArIC43MTUxNTIyICogZyArIC4wNzIxNzUgKiBiKSAvIGQzX2xhYl9ZKSxcbiAgICB6ID0gZDNfeHl6X2xhYigoLjAxOTMzMzkgKiByICsgLjExOTE5MiAqIGcgKyAuOTUwMzA0MSAqIGIpIC8gZDNfbGFiX1opO1xuICByZXR1cm4gZDNfbGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSk7XG59XG5cbmZ1bmN0aW9uIGQzX3JnYl94eXoocikge1xuICByZXR1cm4gKHIgLz0gMjU1KSA8PSAuMDQwNDUgPyByIC8gMTIuOTIgOiBNYXRoLnBvdygociArIC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGQzX3JnYl9wYXJzZU51bWJlcihjKSB7XG4gIHZhciBmID0gcGFyc2VGbG9hdChjKTtcbiAgcmV0dXJuIGMuY2hhckF0KGMubGVuZ3RoIC0gMSkgPT09IFwiJVwiID8gTWF0aC5yb3VuZChmICogMi41NSkgOiBmO1xufVxudmFyIGQzX3JnYl9uYW1lcyA9IGQzLm1hcCh7XG4gIGFsaWNlYmx1ZTogMTU3OTIzODMsXG4gIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gIGFxdWE6IDY1NTM1LFxuICBhcXVhbWFyaW5lOiA4Mzg4NTY0LFxuICBhenVyZTogMTU3OTQxNzUsXG4gIGJlaWdlOiAxNjExOTI2MCxcbiAgYmlzcXVlOiAxNjc3MDI0NCxcbiAgYmxhY2s6IDAsXG4gIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgYmx1ZTogMjU1LFxuICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICBicm93bjogMTA4MjQyMzQsXG4gIGJ1cmx5d29vZDogMTQ1OTYyMzEsXG4gIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgY2hvY29sYXRlOiAxMzc4OTQ3MCxcbiAgY29yYWw6IDE2NzQ0MjcyLFxuICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgY29ybnNpbGs6IDE2Nzc1Mzg4LFxuICBjcmltc29uOiAxNDQyMzEwMCxcbiAgY3lhbjogNjU1MzUsXG4gIGRhcmtibHVlOiAxMzksXG4gIGRhcmtjeWFuOiAzNTcyMyxcbiAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gIGRhcmtncmF5OiAxMTExOTAxNyxcbiAgZGFya2dyZWVuOiAyNTYwMCxcbiAgZGFya2dyZXk6IDExMTE5MDE3LFxuICBkYXJra2hha2k6IDEyNDMzMjU5LFxuICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gIGRhcmtvcmFuZ2U6IDE2NzQ3NTIwLFxuICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgZGFya3JlZDogOTEwOTUwNCxcbiAgZGFya3NhbG1vbjogMTUzMDg0MTAsXG4gIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgZGFya3NsYXRlZ3JheTogMzEwMDQ5NSxcbiAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gIGRhcmt2aW9sZXQ6IDk2OTk1MzksXG4gIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICBkaW1ncmF5OiA2OTA4MjY1LFxuICBkaW1ncmV5OiA2OTA4MjY1LFxuICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICBmaXJlYnJpY2s6IDExNjc0MTQ2LFxuICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICBmdWNoc2lhOiAxNjcxMTkzNSxcbiAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gIGdvbGQ6IDE2NzY2NzIwLFxuICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICBncmF5OiA4NDIxNTA0LFxuICBncmVlbjogMzI3NjgsXG4gIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgZ3JleTogODQyMTUwNCxcbiAgaG9uZXlkZXc6IDE1Nzk0MTYwLFxuICBob3RwaW5rOiAxNjczODc0MCxcbiAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgaW5kaWdvOiA0OTE1MzMwLFxuICBpdm9yeTogMTY3NzcyMDAsXG4gIGtoYWtpOiAxNTc4NzY2MCxcbiAgbGF2ZW5kZXI6IDE1MTMyNDEwLFxuICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICBsZW1vbmNoaWZmb246IDE2Nzc1ODg1LFxuICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgbGlnaHRjeWFuOiAxNDc0NTU5OSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICBsaWdodHNhbG1vbjogMTY3NTI3NjIsXG4gIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgbGlnaHRzbGF0ZWdyYXk6IDc4MzM3NTMsXG4gIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gIGxpZ2h0eWVsbG93OiAxNjc3NzE4NCxcbiAgbGltZTogNjUyODAsXG4gIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgbGluZW46IDE2NDQ1NjcwLFxuICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgbWFyb29uOiA4Mzg4NjA4LFxuICBtZWRpdW1hcXVhbWFyaW5lOiA2NzM3MzIyLFxuICBtZWRpdW1ibHVlOiAyMDUsXG4gIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gIG1lZGl1bXB1cnBsZTogOTY2MjY4MyxcbiAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDY0MTU0LFxuICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gIG1pZG5pZ2h0Ymx1ZTogMTY0NDkxMixcbiAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgbW9jY2FzaW46IDE2NzcwMjI5LFxuICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gIG5hdnk6IDEyOCxcbiAgb2xkbGFjZTogMTY2NDM1NTgsXG4gIG9saXZlOiA4NDIxMzc2LFxuICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gIG9yYW5nZTogMTY3NTM5MjAsXG4gIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gIG9yY2hpZDogMTQzMTU3MzQsXG4gIHBhbGVnb2xkZW5yb2Q6IDE1NjU3MTMwLFxuICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgcGFsZXZpb2xldHJlZDogMTQzODEyMDMsXG4gIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICBwZXJ1OiAxMzQ2ODk5MSxcbiAgcGluazogMTY3NjEwMzUsXG4gIHBsdW06IDE0NTI0NjM3LFxuICBwb3dkZXJibHVlOiAxMTU5MTkxMCxcbiAgcHVycGxlOiA4Mzg4NzM2LFxuICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICByZWQ6IDE2NzExNjgwLFxuICByb3N5YnJvd246IDEyMzU3NTE5LFxuICByb3lhbGJsdWU6IDQyODY5NDUsXG4gIHNhZGRsZWJyb3duOiA5MTI3MTg3LFxuICBzYWxtb246IDE2NDE2ODgyLFxuICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgc2VhZ3JlZW46IDMwNTAzMjcsXG4gIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgc2llbm5hOiAxMDUwNjc5NyxcbiAgc2lsdmVyOiAxMjYzMjI1NixcbiAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICBzbGF0ZWdyYXk6IDczNzI5NDQsXG4gIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgc25vdzogMTY3NzU5MzAsXG4gIHNwcmluZ2dyZWVuOiA2NTQwNyxcbiAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICB0YW46IDEzODA4NzgwLFxuICB0ZWFsOiAzMjg5NixcbiAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gIHRvbWF0bzogMTY3MzcwOTUsXG4gIHR1cnF1b2lzZTogNDI1MTg1NixcbiAgdmlvbGV0OiAxNTYzMTA4NixcbiAgd2hlYXQ6IDE2MTEzMzMxLFxuICB3aGl0ZTogMTY3NzcyMTUsXG4gIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICB5ZWxsb3dncmVlbjogMTAxNDUwNzRcbn0pO1xuZDNfcmdiX25hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBkM19yZ2JfbmFtZXMuc2V0KGtleSwgZDNfcmdiTnVtYmVyKHZhbHVlKSk7XG59KTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJy4vY29sb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhID0gZDMubGFiKGEpO1xuICBiID0gZDMubGFiKGIpO1xuICB2YXIgYWwgPSBhLmwsXG4gICAgICBhYSA9IGEuYSxcbiAgICAgIGFiID0gYS5iLFxuICAgICAgYmwgPSBiLmwgLSBhbCxcbiAgICAgIGJhID0gYi5hIC0gYWEsXG4gICAgICBiYiA9IGIuYiAtIGFiO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkMy5sYWJfcmdiKGFsICsgYmwgKiB0LCBhYSArIGJhICogdCwgYWIgKyBiYiAqIHQpICsgJyc7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbnZhciBkM19jbGFzcyA9IHJlcXVpcmUoJy4vY2xhc3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBkM19NYXA7XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBkM19NYXApIHtcbiAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7IG1hcC5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pO1xuICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZi5jYWxsKG9iamVjdCwgbyA9IG9iamVjdFtpXSwgaSksIG8pO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbmZ1bmN0aW9uIGQzX01hcCgpIHtcbiAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxudmFyIGQzX21hcF9wcm90byA9IFwiX19wcm90b19fXCIsXG4gICAgZDNfbWFwX3plcm8gPSBcIlxcMFwiO1xuXG5kM19jbGFzcyhkM19NYXAsIHtcbiAgaGFzOiBkM19tYXBfaGFzLFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAga2V5czogZDNfbWFwX2tleXMsXG4gIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHZhbHVlcy5wdXNoKHRoaXMuX1trZXldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGVudHJpZXMucHVzaCh7a2V5OiBkM19tYXBfdW5lc2NhcGUoa2V5KSwgdmFsdWU6IHRoaXMuX1trZXldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGQzX21hcF9zaXplLFxuICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpLCB0aGlzLl9ba2V5XSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkM19tYXBfZXNjYXBlKGtleSkge1xuICByZXR1cm4gKGtleSArPSBcIlwiKSA9PT0gZDNfbWFwX3Byb3RvIHx8IGtleVswXSA9PT0gZDNfbWFwX3plcm8gPyBkM19tYXBfemVybyArIGtleSA6IGtleTtcbn1cblxuZnVuY3Rpb24gZDNfbWFwX3VuZXNjYXBlKGtleSkge1xuICByZXR1cm4gKGtleSArPSBcIlwiKVswXSA9PT0gZDNfbWFwX3plcm8gPyBrZXkuc2xpY2UoMSkgOiBrZXk7XG59XG5cbmZ1bmN0aW9uIGQzX21hcF9oYXMoa2V5KSB7XG4gIHJldHVybiBkM19tYXBfZXNjYXBlKGtleSkgaW4gdGhpcy5fO1xufVxuXG5mdW5jdGlvbiBkM19tYXBfcmVtb3ZlKGtleSkge1xuICByZXR1cm4gKGtleSA9IGQzX21hcF9lc2NhcGUoa2V5KSkgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba2V5XTtcbn1cblxuZnVuY3Rpb24gZDNfbWFwX2tleXMoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGtleXMucHVzaChkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBkM19tYXBfc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSArK3NpemU7XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBkM19tYXBfZW1wdHkoKSB7XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqLyIsIi8vIFBhY2thZ2Ugb2YgZGVmaW5pbmcgVmVnYS1saXRlIFNwZWNpZmljYXRpb24ncyBqc29uIHNjaGVtYVxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBzY2hlbWEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0b01hcCA9IHV0aWwudG9NYXAsXG4gIGNvbG9yYnJld2VyID0gcmVxdWlyZSgnLi4vbGliL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyJyk7XG5cbnNjaGVtYS51dGlsID0gcmVxdWlyZSgnLi9zY2hlbWF1dGlsJyk7XG5cbnNjaGVtYS5tYXJrdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsncG9pbnQnLCAndGljaycsICdiYXInLCAnbGluZScsICdhcmVhJywgJ2NpcmNsZScsICdzcXVhcmUnLCAndGV4dCddXG59O1xuXG5zY2hlbWEuYWdncmVnYXRlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydhdmcnLCAnc3VtJywgJ21lZGlhbicsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gIHN1cHBvcnRlZEVudW1zOiB7XG4gICAgUTogWydhdmcnLCAnbWVkaWFuJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gICAgTzogWydtZWRpYW4nLCdtaW4nLCdtYXgnXSxcbiAgICBOOiBbXSxcbiAgICBUOiBbJ2F2ZycsICdtZWRpYW4nLCAnbWluJywgJ21heCddLFxuICAgICcnOiBbJ2NvdW50J11cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBOLCBPLCBULCAnJ10pXG59O1xuc2NoZW1hLmJhbmQgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9XG4gIH1cbn07XG5cbnNjaGVtYS5nZXRTdXBwb3J0ZWRSb2xlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICByZXR1cm4gc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuY29kaW5nLnByb3BlcnRpZXNbZW5jVHlwZV0uc3VwcG9ydGVkUm9sZTtcbn07XG5cbnNjaGVtYS50aW1lVW5pdHMgPSBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2RhdGUnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG5cbnNjaGVtYS5kZWZhdWx0VGltZUZuID0gJ21vbnRoJztcblxuc2NoZW1hLnRpbWVVbml0ID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogc2NoZW1hLnRpbWVVbml0cyxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbn07XG5cbi8vVE9ETyhrYW5pdHcpOiBhZGQgb3RoZXIgdHlwZSBvZiBmdW5jdGlvbiBoZXJlXG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydsaW5lYXInLCAnbG9nJywgJ3BvdycsICdzcXJ0JywgJ3F1YW50aWxlJ10sXG4gIGRlZmF1bHQ6ICdsaW5lYXInLFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1FdKVxufTtcblxuc2NoZW1hLmZpZWxkID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59O1xuXG52YXIgY2xvbmUgPSB1dGlsLmR1cGxpY2F0ZTtcbnZhciBtZXJnZSA9IHNjaGVtYS51dGlsLm1lcmdlO1xuXG5zY2hlbWEuTUFYQklOU19ERUZBVUxUID0gMTU7XG5cbnZhciBiaW4gPSB7XG4gIHR5cGU6IFsnYm9vbGVhbicsICdvYmplY3QnXSxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXhiaW5zOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiBzY2hlbWEuTUFYQklOU19ERUZBVUxULFxuICAgICAgbWluaW11bTogMlxuICAgIH1cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRXSkgLy8gVE9ETzogYWRkIE8gYWZ0ZXIgZmluaXNoaW5nICM4MVxufTtcblxudmFyIHR5cGljYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFtOLCBPLCBRLCBUXVxuICAgIH0sXG4gICAgYWdncmVnYXRlOiBzY2hlbWEuYWdncmVnYXRlLFxuICAgIHRpbWVVbml0OiBzY2hlbWEudGltZVVuaXQsXG4gICAgYmluOiBiaW4sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiBzY2hlbWEuc2NhbGVfdHlwZSxcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIFRdKVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSB6ZXJvJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUSwgVF0pXG4gICAgICAgIH0sXG4gICAgICAgIG5pY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBvbmx5T3JkaW5hbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbTiwgTywgUSwgVF0gLy8gb3JkaW5hbC1vbmx5IGZpZWxkIHN1cHBvcnRzIFEgd2hlbiBiaW4gaXMgYXBwbGllZCBhbmQgVCB3aGVuIHRpbWUgdW5pdCBpcyBhcHBsaWVkLlxuICAgIH0sXG4gICAgdGltZVVuaXQ6IHNjaGVtYS50aW1lVW5pdCxcbiAgICBiaW46IGJpbixcbiAgICBhZ2dyZWdhdGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb3VudCddLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtOLCBPXSkgLy8gRklYTUUgdGhpcyBsb29rcyB3ZWlyZCB0byBtZVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBheGlzTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBheGlzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgYXhpcy4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlT2Zmc2V0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgb2Zmc2V0IHZhbHVlIGZvciB0aGUgYXhpcy4nXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBmb3JtYXR0aW5nIHBhdHRlcm4gZm9yIGF4aXMgbGFiZWxzLidcbiAgICAgICAgfSxcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzb3J0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgc29ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbTiwgT10pLFxuICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ2FnZ3JlZ2F0ZSddLFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAgYWdncmVnYXRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydhdmcnLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBiYW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYmFuZDogc2NoZW1hLmJhbmRcbiAgfVxufTtcblxudmFyIGxlZ2VuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxudmFyIHRleHRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczogeyd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0ZXh0OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgYmFzZWxpbmU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbWlkZGxlJ1xuICAgICAgICB9LFxuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogNCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdib2xkJ10sXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZhbWlseToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdIZWx2ZXRpY2EgTmV1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdpdGFsaWMnXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2l6ZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGJhcjogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMwLFxuICAgICAgbWluaW11bTogMFxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbG9yTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnc3RlZWxibHVlJ1xuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByYW5nZToge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGFscGhhTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxXG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hhcGVNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS11cCcsICd0cmlhbmdsZS1kb3duJ10sXG4gICAgICBkZWZhdWx0OiAnY2lyY2xlJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldGFpbE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGxpbmU6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfVxufTtcblxudmFyIHJvd01peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGdyaWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgZmxhZyBpbmRpY2F0ZSBpZiBncmlkbGluZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gYWRkaXRpb24gdG8gdGlja3MuJ1xuICAgIH0sXG4gIH1cbn07XG5cbnZhciBjb2xNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWNldE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJlcXVpcmVkTmFtZVR5cGUgPSB7XG4gIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddXG59O1xuXG52YXIgbXVsdGlSb2xlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9XG59KTtcblxudmFyIHF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246ICdvcmRpbmFsLW9ubHknIC8vIHVzaW5nIGFscGhhIC8gc2l6ZSB0byBlbmNvZGluZyBjYXRlZ29yeSBsZWFkIHRvIG9yZGVyIGludGVycHJldGF0aW9uXG4gIH1cbn0pO1xuXG52YXIgb25seVF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHggPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGF4aXNNaXhpbiwgYmFuZE1peGluLCByZXF1aXJlZE5hbWVUeXBlLCBzb3J0TWl4aW4pO1xudmFyIHkgPSBjbG9uZSh4KTtcblxudmFyIGZhY2V0ID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIHJlcXVpcmVkTmFtZVR5cGUsIGZhY2V0TWl4aW4sIHNvcnRNaXhpbik7XG52YXIgcm93ID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIHJvd01peGluKTtcbnZhciBjb2wgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgY29sTWl4aW4pO1xuXG52YXIgc2l6ZSA9IG1lcmdlKGNsb25lKHF1YW50aXRhdGl2ZUZpZWxkKSwgbGVnZW5kTWl4aW4sIHNpemVNaXhpbiwgc29ydE1peGluKTtcbnZhciBjb2xvciA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgbGVnZW5kTWl4aW4sIGNvbG9yTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgYWxwaGEgPSBtZXJnZShjbG9uZShxdWFudGl0YXRpdmVGaWVsZCksIGFscGhhTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgc2hhcGUgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgbGVnZW5kTWl4aW4sIHNoYXBlTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgZGV0YWlsID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGRldGFpbE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyB3ZSBvbmx5IHB1dCBhZ2dyZWdhdGVkIG1lYXN1cmUgaW4gcGl2b3QgdGFibGVcbnZhciB0ZXh0ID0gbWVyZ2UoY2xvbmUob25seVF1YW50aXRhdGl2ZUZpZWxkKSwgdGV4dE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyBUT0RPIGFkZCBsYWJlbFxuXG52YXIgZmlsdGVyID0ge1xuICB0eXBlOiAnYXJyYXknLFxuICBpdGVtczoge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIG9wZXJhbmRzOiB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlciddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcjoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZW51bTogWyc+JywgJz49JywgJz0nLCAnIT0nLCAnPCcsICc8PScsICdub3ROdWxsJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBkYXRhID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIGRhdGEgc291cmNlXG4gICAgZm9ybWF0VHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2pzb24nLCAnY3N2J10sXG4gICAgICBkZWZhdWx0OiAnanNvbidcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUGFzcyBhcnJheSBvZiBvYmplY3RzIGluc3RlYWQgb2YgYSB1cmwgdG8gYSBmaWxlLicsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb25maWcgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gdGVtcGxhdGVcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcidcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ2JsYWNrJ1xuICAgIH0sXG4gICAgZ3JpZE9wYWNpdHk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjA4XG4gICAgfSxcblxuICAgIC8vIGZpbHRlciBudWxsXG4gICAgZmlsdGVyTnVsbDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIE86IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogZmFsc2V9LFxuICAgICAgICBROiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9LFxuICAgICAgICBUOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9XG4gICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVTb3J0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IE9cbiAgICB9LFxuXG4gICAgLy8gc2luZ2xlIHBsb3RcbiAgICBzaW5nbGVIZWlnaHQ6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNpbmdsZVdpZHRoOiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBiYW5kIHNpemVcbiAgICBsYXJnZUJhbmRTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNtYWxsQmFuZFNpemU6IHtcbiAgICAgIC8vc21hbGwgbXVsdGlwbGVzIG9yIHNpbmdsZSBwbG90IHdpdGggaGlnaCBjYXJkaW5hbGl0eVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTBcbiAgICB9LFxuICAgIC8vIHNtYWxsIG11bHRpcGxlc1xuICAgIGNlbGxQYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH0sXG4gICAgY2VsbEdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ2JsYWNrJ1xuICAgIH0sXG4gICAgY2VsbEdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xNVxuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVCYXJPZmZzZXQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIGNvbG9yXG4gICAgYzEwcGFsZXR0ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnY2F0ZWdvcnkxMCcsXG4gICAgICBlbnVtOiBbXG4gICAgICAgIC8vIFRhYmxlYXVcbiAgICAgICAgJ2NhdGVnb3J5MTAnLCAnY2F0ZWdvcnkxMGsnLFxuICAgICAgICAvLyBDb2xvciBCcmV3ZXJcbiAgICAgICAgJ1Bhc3RlbDEnLCAnUGFzdGVsMicsICdTZXQxJywgJ1NldDInLCAnU2V0MydcbiAgICAgIF1cbiAgICB9LFxuICAgIGMyMHBhbGV0dGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ2NhdGVnb3J5MjAnLFxuICAgICAgZW51bTogWydjYXRlZ29yeTIwJywgJ2NhdGVnb3J5MjBiJywgJ2NhdGVnb3J5MjBjJ11cbiAgICB9LFxuICAgIG9yZGluYWxQYWxldHRlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdCdUduJyxcbiAgICAgIGVudW06IHV0aWwua2V5cyhjb2xvcmJyZXdlcilcbiAgICB9LFxuXG4gICAgLy8gc2NhbGVzXG4gICAgdGltZVNjYWxlTGFiZWxMZW5ndGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBvdGhlclxuICAgIGNoYXJhY3RlcldpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA2XG4gICAgfVxuICB9XG59O1xuXG4vKiogQHR5cGUgT2JqZWN0IFNjaGVtYSBvZiBhIHZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uICovXG5zY2hlbWEuc2NoZW1hID0ge1xuICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJyxcbiAgZGVzY3JpcHRpb246ICdTY2hlbWEgZm9yIFZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIHJlcXVpcmVkOiBbJ21hcmt0eXBlJywgJ2VuY29kaW5nJywgJ2RhdGEnXSxcbiAgcHJvcGVydGllczoge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgbWFya3R5cGU6IHNjaGVtYS5tYXJrdHlwZSxcbiAgICBlbmNvZGluZzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jb2RpbmcucHJvcGVydGllcyk7XG5cbi8qKiBJbnN0YW50aWF0ZSBhIHZlcmJvc2Ugdmwgc3BlYyBmcm9tIHRoZSBzY2hlbWEgKi9cbnNjaGVtYS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NoZW1hdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbnNjaGVtYXV0aWwuZXh0ZW5kID0gZnVuY3Rpb24oaW5zdGFuY2UsIHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hdXRpbC5tZXJnZShzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYSksIGluc3RhbmNlKTtcbn07XG5cbi8vIGluc3RhbnRpYXRlIGEgc2NoZW1hXG5zY2hlbWF1dGlsLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIHZhciB2YWw7XG4gIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHZhbCA9IHNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiB1dGlsLmlzT2JqZWN0KHZhbCkgPyB1dGlsLmR1cGxpY2F0ZSh2YWwpIDogdmFsO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBpbnN0YW5jZSA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhbCA9IHNjaGVtYXV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIHJlbW92ZSBhbGwgZGVmYXVsdHMgZnJvbSBhbiBpbnN0YW5jZVxuc2NoZW1hdXRpbC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBkZWZhdWx0cykge1xuICB2YXIgY2hhbmdlcyA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGluc3RhbmNlKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIHZhciBpbnMgPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAvLyBOb3RlOiBkb2VzIG5vdCBwcm9wZXJseSBzdWJ0cmFjdCBhcnJheXNcbiAgICBpZiAoIWRlZmF1bHRzIHx8IGRlZiAhPT0gaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGlucyA9PT0gJ29iamVjdCcgJiYgIXV0aWwuaXNBcnJheShpbnMpICYmIGRlZikge1xuICAgICAgICB2YXIgYyA9IHNjaGVtYXV0aWwuc3VidHJhY3QoaW5zLCBkZWYpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoYykpXG4gICAgICAgICAgY2hhbmdlc1twcm9wXSA9IGM7XG4gICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzQXJyYXkoaW5zKSB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gaW5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnNjaGVtYXV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0W3BdICE9PSAnb2JqZWN0JyB8fCBkZXN0W3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gbWVyZ2Uoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlKGRlc3RbcF0sIHNyY1twXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3V0aWwnKTtcblxudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvZ2VuZXJhdGUnKSk7XG51dGlsLmJpbiA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2JpbnMvYmlucycpO1xuXG51dGlsLmlzaW4gPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG51dGlsLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2guY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgayAsIG9iaik7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLnJlZHVjZSA9IGZ1bmN0aW9uKG9iaiwgZiwgaW5pdCwgdGhpc0FyZykge1xuICBpZiAob2JqLnJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlLmNhbGwodGhpc0FyZywgZiwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGluaXQgPSBmLmNhbGwodGhpc0FyZywgaW5pdCwgb2JqW2tdLCBrLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxufTtcblxudXRpbC5tYXAgPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5tYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgb3V0cHV0LnB1c2goIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGssIG9iaikpO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5hbnkgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKGYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG51dGlsLmFsbCA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoIWYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG51dGlsLmdldGJpbnMgPSBmdW5jdGlvbihzdGF0cywgbWF4Ymlucykge1xuICByZXR1cm4gdXRpbC5iaW4oe1xuICAgIG1pbjogc3RhdHMubWluLFxuICAgIG1heDogc3RhdHMubWF4LFxuICAgIG1heGJpbnM6IG1heGJpbnNcbiAgfSk7XG59O1xuXG4vKipcbiAqIHhbcFswXV0uLi5bcFtuXV0gPSB2YWxcbiAqIEBwYXJhbSBub2F1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5zZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCB2YWwsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGgtMTsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICB4W3BbaV1dID0gdmFsO1xufTtcblxuXG4vKipcbiAqIHJldHVybnMgeFtwWzBdXS4uLltwW25dXVxuICogQHBhcmFtIGF1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5nZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufTtcblxudXRpbC5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICBjb25zb2xlLmVycm9yKCdbVkwgRXJyb3JdJywgbXNnKTtcbn07XG5cbiJdfQ==\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n    return vlfield.fieldRef(this._enc[et], {\n      nofn: nofn,\n      data: !this._vega2 && !nodata\n    });\n  };\n\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var timeUnit = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (timeUnit) {\n      return timeUnit.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.timeUnit = function(et) {\n    return this._enc[et].timeUnit;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = vlfield.isType;\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = 'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else {\n      setter(def, ['properties', 'grid'], {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var timeUnit;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (timeUnit = encoding.timeUnit(name)) && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, '{{data | number:\\'.3s\\'}}');\n  } else if (encoding.isType(name, T)) {\n    if (!encoding.timeUnit(name)) {\n      setter(def, textTemplatePath, '{{data | time:\\'%Y-%m-%d\\'}}');\n    } else if (encoding.timeUnit(name) === 'year') {\n      setter(def, textTemplatePath, '{{data | number:\\'d\\'}}');\n    }\n  } else if (encoding.isType(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.field(encType, false, /*nofn*/ true),\n        output: encoding.field(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compile.layout(encoding, stats),\n    spec = compile.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  dataTable = compile.bin(dataTable, encoding);     // modify dataTable\n  spec = compile.time(spec, encoding);              // modify dataTable, add scales\n  var aggResult = compile.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compile.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compile.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter;\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggregate(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (timeUnit = encoding.timeUnit(name)) &&\n    time.hasScale(timeUnit)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.field(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.field(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.field(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: '{{' + e.field(TEXT) + ' | number:\\'.3s\\'}}'};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('../lib/colorbrewer/colorbrewer'),\n  interpolateLab = require('../lib/d3-color/interpolate-lab');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, stats, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.timeUnit(name);\n      return (timeUnit && time.scale.type(timeUnit, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.timeUnit(name), name);\n    if(range) return range;\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        fn: (opt.facet ? 'max_' : '') + 'sum'\n      })\n    };\n  }\n  return {data: sorting.getDataset(name), field: encoding.field(name)};\n};\n\n\nfunction scale_range(s, encoding, layout, stats, style, opt) {\n  // jshint unused:false\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.timeUnit(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.timeUnit(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.timeUnit(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.timeUnit(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\nscale.color = function(s, encoding, stats) {\n  var range = encoding.scale(COLOR).range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = encoding.config('ordinalPalette');\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = 'category10-k';\n        } else {\n          range = 'category20';\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    time.scale(scales, timeUnit, encoding);\n  }\n  return spec;\n}\n\n\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (timeUnit) {\n    case 'day':\n      scales.push({\n        name: 'time-'+timeUnit,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+timeUnit,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\n","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  N: 0,\n  O: 1,\n  G: 2,\n  T: 3,\n  Q: 4\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggregate==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\nmodule.exports = {YlGn: {\n3: ['#f7fcb9','#addd8e','#31a354'],\n4: ['#ffffcc','#c2e699','#78c679','#238443'],\n5: ['#ffffcc','#c2e699','#78c679','#31a354','#006837'],\n6: ['#ffffcc','#d9f0a3','#addd8e','#78c679','#31a354','#006837'],\n7: ['#ffffcc','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#005a32'],\n8: ['#ffffe5','#f7fcb9','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#005a32'],\n9: ['#ffffe5','#f7fcb9','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#006837','#004529']\n},YlGnBu: {\n3: ['#edf8b1','#7fcdbb','#2c7fb8'],\n4: ['#ffffcc','#a1dab4','#41b6c4','#225ea8'],\n5: ['#ffffcc','#a1dab4','#41b6c4','#2c7fb8','#253494'],\n6: ['#ffffcc','#c7e9b4','#7fcdbb','#41b6c4','#2c7fb8','#253494'],\n7: ['#ffffcc','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#0c2c84'],\n8: ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#0c2c84'],\n9: ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#253494','#081d58']\n},GnBu: {\n3: ['#e0f3db','#a8ddb5','#43a2ca'],\n4: ['#f0f9e8','#bae4bc','#7bccc4','#2b8cbe'],\n5: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],\n6: ['#f0f9e8','#ccebc5','#a8ddb5','#7bccc4','#43a2ca','#0868ac'],\n7: ['#f0f9e8','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#08589e'],\n8: ['#f7fcf0','#e0f3db','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#08589e'],\n9: ['#f7fcf0','#e0f3db','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#0868ac','#084081']\n},BuGn: {\n3: ['#e5f5f9','#99d8c9','#2ca25f'],\n4: ['#edf8fb','#b2e2e2','#66c2a4','#238b45'],\n5: ['#edf8fb','#b2e2e2','#66c2a4','#2ca25f','#006d2c'],\n6: ['#edf8fb','#ccece6','#99d8c9','#66c2a4','#2ca25f','#006d2c'],\n7: ['#edf8fb','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#005824'],\n8: ['#f7fcfd','#e5f5f9','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#005824'],\n9: ['#f7fcfd','#e5f5f9','#ccece6','#99d8c9','#66c2a4','#41ae76','#238b45','#006d2c','#00441b']\n},PuBuGn: {\n3: ['#ece2f0','#a6bddb','#1c9099'],\n4: ['#f6eff7','#bdc9e1','#67a9cf','#02818a'],\n5: ['#f6eff7','#bdc9e1','#67a9cf','#1c9099','#016c59'],\n6: ['#f6eff7','#d0d1e6','#a6bddb','#67a9cf','#1c9099','#016c59'],\n7: ['#f6eff7','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016450'],\n8: ['#fff7fb','#ece2f0','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016450'],\n9: ['#fff7fb','#ece2f0','#d0d1e6','#a6bddb','#67a9cf','#3690c0','#02818a','#016c59','#014636']\n},PuBu: {\n3: ['#ece7f2','#a6bddb','#2b8cbe'],\n4: ['#f1eef6','#bdc9e1','#74a9cf','#0570b0'],\n5: ['#f1eef6','#bdc9e1','#74a9cf','#2b8cbe','#045a8d'],\n6: ['#f1eef6','#d0d1e6','#a6bddb','#74a9cf','#2b8cbe','#045a8d'],\n7: ['#f1eef6','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#034e7b'],\n8: ['#fff7fb','#ece7f2','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#034e7b'],\n9: ['#fff7fb','#ece7f2','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#045a8d','#023858']\n},BuPu: {\n3: ['#e0ecf4','#9ebcda','#8856a7'],\n4: ['#edf8fb','#b3cde3','#8c96c6','#88419d'],\n5: ['#edf8fb','#b3cde3','#8c96c6','#8856a7','#810f7c'],\n6: ['#edf8fb','#bfd3e6','#9ebcda','#8c96c6','#8856a7','#810f7c'],\n7: ['#edf8fb','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#6e016b'],\n8: ['#f7fcfd','#e0ecf4','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#6e016b'],\n9: ['#f7fcfd','#e0ecf4','#bfd3e6','#9ebcda','#8c96c6','#8c6bb1','#88419d','#810f7c','#4d004b']\n},RdPu: {\n3: ['#fde0dd','#fa9fb5','#c51b8a'],\n4: ['#feebe2','#fbb4b9','#f768a1','#ae017e'],\n5: ['#feebe2','#fbb4b9','#f768a1','#c51b8a','#7a0177'],\n6: ['#feebe2','#fcc5c0','#fa9fb5','#f768a1','#c51b8a','#7a0177'],\n7: ['#feebe2','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177'],\n8: ['#fff7f3','#fde0dd','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177'],\n9: ['#fff7f3','#fde0dd','#fcc5c0','#fa9fb5','#f768a1','#dd3497','#ae017e','#7a0177','#49006a']\n},PuRd: {\n3: ['#e7e1ef','#c994c7','#dd1c77'],\n4: ['#f1eef6','#d7b5d8','#df65b0','#ce1256'],\n5: ['#f1eef6','#d7b5d8','#df65b0','#dd1c77','#980043'],\n6: ['#f1eef6','#d4b9da','#c994c7','#df65b0','#dd1c77','#980043'],\n7: ['#f1eef6','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#91003f'],\n8: ['#f7f4f9','#e7e1ef','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#91003f'],\n9: ['#f7f4f9','#e7e1ef','#d4b9da','#c994c7','#df65b0','#e7298a','#ce1256','#980043','#67001f']\n},OrRd: {\n3: ['#fee8c8','#fdbb84','#e34a33'],\n4: ['#fef0d9','#fdcc8a','#fc8d59','#d7301f'],\n5: ['#fef0d9','#fdcc8a','#fc8d59','#e34a33','#b30000'],\n6: ['#fef0d9','#fdd49e','#fdbb84','#fc8d59','#e34a33','#b30000'],\n7: ['#fef0d9','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#990000'],\n8: ['#fff7ec','#fee8c8','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#990000'],\n9: ['#fff7ec','#fee8c8','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f','#b30000','#7f0000']\n},YlOrRd: {\n3: ['#ffeda0','#feb24c','#f03b20'],\n4: ['#ffffb2','#fecc5c','#fd8d3c','#e31a1c'],\n5: ['#ffffb2','#fecc5c','#fd8d3c','#f03b20','#bd0026'],\n6: ['#ffffb2','#fed976','#feb24c','#fd8d3c','#f03b20','#bd0026'],\n7: ['#ffffb2','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'],\n8: ['#ffffcc','#ffeda0','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'],\n9: ['#ffffcc','#ffeda0','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#bd0026','#800026']\n},YlOrBr: {\n3: ['#fff7bc','#fec44f','#d95f0e'],\n4: ['#ffffd4','#fed98e','#fe9929','#cc4c02'],\n5: ['#ffffd4','#fed98e','#fe9929','#d95f0e','#993404'],\n6: ['#ffffd4','#fee391','#fec44f','#fe9929','#d95f0e','#993404'],\n7: ['#ffffd4','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#8c2d04'],\n8: ['#ffffe5','#fff7bc','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#8c2d04'],\n9: ['#ffffe5','#fff7bc','#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#993404','#662506']\n},Purples: {\n3: ['#efedf5','#bcbddc','#756bb1'],\n4: ['#f2f0f7','#cbc9e2','#9e9ac8','#6a51a3'],\n5: ['#f2f0f7','#cbc9e2','#9e9ac8','#756bb1','#54278f'],\n6: ['#f2f0f7','#dadaeb','#bcbddc','#9e9ac8','#756bb1','#54278f'],\n7: ['#f2f0f7','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#4a1486'],\n8: ['#fcfbfd','#efedf5','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#4a1486'],\n9: ['#fcfbfd','#efedf5','#dadaeb','#bcbddc','#9e9ac8','#807dba','#6a51a3','#54278f','#3f007d']\n},Blues: {\n3: ['#deebf7','#9ecae1','#3182bd'],\n4: ['#eff3ff','#bdd7e7','#6baed6','#2171b5'],\n5: ['#eff3ff','#bdd7e7','#6baed6','#3182bd','#08519c'],\n6: ['#eff3ff','#c6dbef','#9ecae1','#6baed6','#3182bd','#08519c'],\n7: ['#eff3ff','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'],\n8: ['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'],\n9: ['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']\n},Greens: {\n3: ['#e5f5e0','#a1d99b','#31a354'],\n4: ['#edf8e9','#bae4b3','#74c476','#238b45'],\n5: ['#edf8e9','#bae4b3','#74c476','#31a354','#006d2c'],\n6: ['#edf8e9','#c7e9c0','#a1d99b','#74c476','#31a354','#006d2c'],\n7: ['#edf8e9','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#005a32'],\n8: ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#005a32'],\n9: ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#006d2c','#00441b']\n},Oranges: {\n3: ['#fee6ce','#fdae6b','#e6550d'],\n4: ['#feedde','#fdbe85','#fd8d3c','#d94701'],\n5: ['#feedde','#fdbe85','#fd8d3c','#e6550d','#a63603'],\n6: ['#feedde','#fdd0a2','#fdae6b','#fd8d3c','#e6550d','#a63603'],\n7: ['#feedde','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#8c2d04'],\n8: ['#fff5eb','#fee6ce','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#8c2d04'],\n9: ['#fff5eb','#fee6ce','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#a63603','#7f2704']\n},Reds: {\n3: ['#fee0d2','#fc9272','#de2d26'],\n4: ['#fee5d9','#fcae91','#fb6a4a','#cb181d'],\n5: ['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15'],\n6: ['#fee5d9','#fcbba1','#fc9272','#fb6a4a','#de2d26','#a50f15'],\n7: ['#fee5d9','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#99000d'],\n8: ['#fff5f0','#fee0d2','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#99000d'],\n9: ['#fff5f0','#fee0d2','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#a50f15','#67000d']\n},Greys: {\n3: ['#f0f0f0','#bdbdbd','#636363'],\n4: ['#f7f7f7','#cccccc','#969696','#525252'],\n5: ['#f7f7f7','#cccccc','#969696','#636363','#252525'],\n6: ['#f7f7f7','#d9d9d9','#bdbdbd','#969696','#636363','#252525'],\n7: ['#f7f7f7','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525'],\n8: ['#ffffff','#f0f0f0','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525'],\n9: ['#ffffff','#f0f0f0','#d9d9d9','#bdbdbd','#969696','#737373','#525252','#252525','#000000']\n},PuOr: {\n3: ['#f1a340','#f7f7f7','#998ec3'],\n4: ['#e66101','#fdb863','#b2abd2','#5e3c99'],\n5: ['#e66101','#fdb863','#f7f7f7','#b2abd2','#5e3c99'],\n6: ['#b35806','#f1a340','#fee0b6','#d8daeb','#998ec3','#542788'],\n7: ['#b35806','#f1a340','#fee0b6','#f7f7f7','#d8daeb','#998ec3','#542788'],\n8: ['#b35806','#e08214','#fdb863','#fee0b6','#d8daeb','#b2abd2','#8073ac','#542788'],\n9: ['#b35806','#e08214','#fdb863','#fee0b6','#f7f7f7','#d8daeb','#b2abd2','#8073ac','#542788'],\n10: ['#7f3b08','#b35806','#e08214','#fdb863','#fee0b6','#d8daeb','#b2abd2','#8073ac','#542788','#2d004b'],\n11: ['#7f3b08','#b35806','#e08214','#fdb863','#fee0b6','#f7f7f7','#d8daeb','#b2abd2','#8073ac','#542788','#2d004b']\n},BrBG: {\n3: ['#d8b365','#f5f5f5','#5ab4ac'],\n4: ['#a6611a','#dfc27d','#80cdc1','#018571'],\n5: ['#a6611a','#dfc27d','#f5f5f5','#80cdc1','#018571'],\n6: ['#8c510a','#d8b365','#f6e8c3','#c7eae5','#5ab4ac','#01665e'],\n7: ['#8c510a','#d8b365','#f6e8c3','#f5f5f5','#c7eae5','#5ab4ac','#01665e'],\n8: ['#8c510a','#bf812d','#dfc27d','#f6e8c3','#c7eae5','#80cdc1','#35978f','#01665e'],\n9: ['#8c510a','#bf812d','#dfc27d','#f6e8c3','#f5f5f5','#c7eae5','#80cdc1','#35978f','#01665e'],\n10: ['#543005','#8c510a','#bf812d','#dfc27d','#f6e8c3','#c7eae5','#80cdc1','#35978f','#01665e','#003c30'],\n11: ['#543005','#8c510a','#bf812d','#dfc27d','#f6e8c3','#f5f5f5','#c7eae5','#80cdc1','#35978f','#01665e','#003c30']\n},PRGn: {\n3: ['#af8dc3','#f7f7f7','#7fbf7b'],\n4: ['#7b3294','#c2a5cf','#a6dba0','#008837'],\n5: ['#7b3294','#c2a5cf','#f7f7f7','#a6dba0','#008837'],\n6: ['#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837'],\n7: ['#762a83','#af8dc3','#e7d4e8','#f7f7f7','#d9f0d3','#7fbf7b','#1b7837'],\n8: ['#762a83','#9970ab','#c2a5cf','#e7d4e8','#d9f0d3','#a6dba0','#5aae61','#1b7837'],\n9: ['#762a83','#9970ab','#c2a5cf','#e7d4e8','#f7f7f7','#d9f0d3','#a6dba0','#5aae61','#1b7837'],\n10: ['#40004b','#762a83','#9970ab','#c2a5cf','#e7d4e8','#d9f0d3','#a6dba0','#5aae61','#1b7837','#00441b'],\n11: ['#40004b','#762a83','#9970ab','#c2a5cf','#e7d4e8','#f7f7f7','#d9f0d3','#a6dba0','#5aae61','#1b7837','#00441b']\n},PiYG: {\n3: ['#e9a3c9','#f7f7f7','#a1d76a'],\n4: ['#d01c8b','#f1b6da','#b8e186','#4dac26'],\n5: ['#d01c8b','#f1b6da','#f7f7f7','#b8e186','#4dac26'],\n6: ['#c51b7d','#e9a3c9','#fde0ef','#e6f5d0','#a1d76a','#4d9221'],\n7: ['#c51b7d','#e9a3c9','#fde0ef','#f7f7f7','#e6f5d0','#a1d76a','#4d9221'],\n8: ['#c51b7d','#de77ae','#f1b6da','#fde0ef','#e6f5d0','#b8e186','#7fbc41','#4d9221'],\n9: ['#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221'],\n10: ['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419'],\n11: ['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419']\n},RdBu: {\n3: ['#ef8a62','#f7f7f7','#67a9cf'],\n4: ['#ca0020','#f4a582','#92c5de','#0571b0'],\n5: ['#ca0020','#f4a582','#f7f7f7','#92c5de','#0571b0'],\n6: ['#b2182b','#ef8a62','#fddbc7','#d1e5f0','#67a9cf','#2166ac'],\n7: ['#b2182b','#ef8a62','#fddbc7','#f7f7f7','#d1e5f0','#67a9cf','#2166ac'],\n8: ['#b2182b','#d6604d','#f4a582','#fddbc7','#d1e5f0','#92c5de','#4393c3','#2166ac'],\n9: ['#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac'],\n10: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061'],\n11: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061']\n},RdGy: {\n3: ['#ef8a62','#ffffff','#999999'],\n4: ['#ca0020','#f4a582','#bababa','#404040'],\n5: ['#ca0020','#f4a582','#ffffff','#bababa','#404040'],\n6: ['#b2182b','#ef8a62','#fddbc7','#e0e0e0','#999999','#4d4d4d'],\n7: ['#b2182b','#ef8a62','#fddbc7','#ffffff','#e0e0e0','#999999','#4d4d4d'],\n8: ['#b2182b','#d6604d','#f4a582','#fddbc7','#e0e0e0','#bababa','#878787','#4d4d4d'],\n9: ['#b2182b','#d6604d','#f4a582','#fddbc7','#ffffff','#e0e0e0','#bababa','#878787','#4d4d4d'],\n10: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#e0e0e0','#bababa','#878787','#4d4d4d','#1a1a1a'],\n11: ['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#ffffff','#e0e0e0','#bababa','#878787','#4d4d4d','#1a1a1a']\n},RdYlBu: {\n3: ['#fc8d59','#ffffbf','#91bfdb'],\n4: ['#d7191c','#fdae61','#abd9e9','#2c7bb6'],\n5: ['#d7191c','#fdae61','#ffffbf','#abd9e9','#2c7bb6'],\n6: ['#d73027','#fc8d59','#fee090','#e0f3f8','#91bfdb','#4575b4'],\n7: ['#d73027','#fc8d59','#fee090','#ffffbf','#e0f3f8','#91bfdb','#4575b4'],\n8: ['#d73027','#f46d43','#fdae61','#fee090','#e0f3f8','#abd9e9','#74add1','#4575b4'],\n9: ['#d73027','#f46d43','#fdae61','#fee090','#ffffbf','#e0f3f8','#abd9e9','#74add1','#4575b4'],\n10: ['#a50026','#d73027','#f46d43','#fdae61','#fee090','#e0f3f8','#abd9e9','#74add1','#4575b4','#313695'],\n11: ['#a50026','#d73027','#f46d43','#fdae61','#fee090','#ffffbf','#e0f3f8','#abd9e9','#74add1','#4575b4','#313695']\n},Spectral: {\n3: ['#fc8d59','#ffffbf','#99d594'],\n4: ['#d7191c','#fdae61','#abdda4','#2b83ba'],\n5: ['#d7191c','#fdae61','#ffffbf','#abdda4','#2b83ba'],\n6: ['#d53e4f','#fc8d59','#fee08b','#e6f598','#99d594','#3288bd'],\n7: ['#d53e4f','#fc8d59','#fee08b','#ffffbf','#e6f598','#99d594','#3288bd'],\n8: ['#d53e4f','#f46d43','#fdae61','#fee08b','#e6f598','#abdda4','#66c2a5','#3288bd'],\n9: ['#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd'],\n10: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2'],\n11: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2']\n},RdYlGn: {\n3: ['#fc8d59','#ffffbf','#91cf60'],\n4: ['#d7191c','#fdae61','#a6d96a','#1a9641'],\n5: ['#d7191c','#fdae61','#ffffbf','#a6d96a','#1a9641'],\n6: ['#d73027','#fc8d59','#fee08b','#d9ef8b','#91cf60','#1a9850'],\n7: ['#d73027','#fc8d59','#fee08b','#ffffbf','#d9ef8b','#91cf60','#1a9850'],\n8: ['#d73027','#f46d43','#fdae61','#fee08b','#d9ef8b','#a6d96a','#66bd63','#1a9850'],\n9: ['#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850'],\n10: ['#a50026','#d73027','#f46d43','#fdae61','#fee08b','#d9ef8b','#a6d96a','#66bd63','#1a9850','#006837'],\n11: ['#a50026','#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850','#006837']\n},Accent: {\n3: ['#7fc97f','#beaed4','#fdc086'],\n4: ['#7fc97f','#beaed4','#fdc086','#ffff99'],\n5: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0'],\n6: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f'],\n7: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17'],\n8: ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666']\n},Dark2: {\n3: ['#1b9e77','#d95f02','#7570b3'],\n4: ['#1b9e77','#d95f02','#7570b3','#e7298a'],\n5: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'],\n6: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02'],\n7: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d'],\n8: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666']\n},Paired: {\n3: ['#a6cee3','#1f78b4','#b2df8a'],\n4: ['#a6cee3','#1f78b4','#b2df8a','#33a02c'],\n5: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99'],\n6: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c'],\n7: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f'],\n8: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00'],\n9: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6'],\n10: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a'],\n11: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99'],\n12: ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928']\n},Pastel1: {\n3: ['#fbb4ae','#b3cde3','#ccebc5'],\n4: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4'],\n5: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6'],\n6: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc'],\n7: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd'],\n8: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd','#fddaec'],\n9: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd','#fddaec','#f2f2f2']\n},Pastel2: {\n3: ['#b3e2cd','#fdcdac','#cbd5e8'],\n4: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4'],\n5: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9'],\n6: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae'],\n7: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae','#f1e2cc'],\n8: ['#b3e2cd','#fdcdac','#cbd5e8','#f4cae4','#e6f5c9','#fff2ae','#f1e2cc','#cccccc']\n},Set1: {\n3: ['#e41a1c','#377eb8','#4daf4a'],\n4: ['#e41a1c','#377eb8','#4daf4a','#984ea3'],\n5: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00'],\n6: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33'],\n7: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628'],\n8: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'],\n9: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999']\n},Set2: {\n3: ['#66c2a5','#fc8d62','#8da0cb'],\n4: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3'],\n5: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854'],\n6: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f'],\n7: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'],\n8: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494','#b3b3b3']\n},Set3: {\n3: ['#8dd3c7','#ffffb3','#bebada'],\n4: ['#8dd3c7','#ffffb3','#bebada','#fb8072'],\n5: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3'],\n6: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462'],\n7: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69'],\n8: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5'],\n9: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9'],\n10: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd'],\n11: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5'],\n12: ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5','#ffed6f']\n}};","'use strict';\n\nmodule.exports = function d3_class(ctor, properties) {\n  for (var key in properties) {\n    Object.defineProperty(ctor.prototype, key, {\n      value: properties[key],\n      enumerable: false\n    });\n  }\n};","'use strict';\n/* jshint ignore:start */\n\nvar d3 = module.exports = {\n  map: require('./map')\n};\n\nd3.color = d3_color;\n\nfunction d3_color() {}\nd3_color.prototype.toString = function() {\n  return this.rgb() + '';\n};\nd3.hsl = d3_hsl;\n\nfunction d3_hsl(h, s, l) {\n\n  return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length <\n    2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl,\n      d3_hsl) : new d3_hsl(h, s, l);\n}\nvar d3_hslPrototype = d3_hsl.prototype = new d3_color();\nd3_hslPrototype.brighter = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_hsl(this.h, this.s, this.l / k);\n};\nd3_hslPrototype.darker = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_hsl(this.h, this.s, k * this.l);\n};\nd3_hslPrototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1, m2;\n  h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n  s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n  return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nd3.hcl = d3_hcl;\n\nfunction d3_hcl(h, c, l) {\n  return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length <\n    2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l,\n      h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(\n      h, c, l);\n}\nvar d3_hclPrototype = d3_hcl.prototype = new d3_color();\nd3_hclPrototype.brighter = function(k) {\n  return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n};\nd3_hclPrototype.darker = function(k) {\n  return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n};\nd3_hclPrototype.rgb = function() {\n  return d3_hcl_lab(this.h, this.c, this.l).rgb();\n};\n\nfunction d3_hcl_lab(h, c, l) {\n  if (isNaN(h)) h = 0;\n  if (isNaN(c)) c = 0;\n  return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n}\nd3.lab = d3_lab;\n\nfunction d3_lab(l, a, b) {\n  return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length <\n    2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h,\n      l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n}\nvar d3_lab_K = 18;\nvar d3_lab_X = .95047,\n  d3_lab_Y = 1,\n  d3_lab_Z = 1.08883;\nvar d3_labPrototype = d3_lab.prototype = new d3_color();\nd3_labPrototype.brighter = function(k) {\n  return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this\n    .b);\n};\nd3_labPrototype.darker = function(k) {\n  return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n};\nd3_labPrototype.rgb = function() {\n  return d3_lab_rgb(this.l, this.a, this.b);\n};\n\nd3.lab_rgb = function d3_lab_rgb(l, a, b) {\n  var y = (l + 16) / 116,\n    x = y + a / 500,\n    z = y - b / 200;\n  x = d3_lab_xyz(x) * d3_lab_X;\n  y = d3_lab_xyz(y) * d3_lab_Y;\n  z = d3_lab_xyz(z) * d3_lab_Z;\n  return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 *\n    x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 *\n    z));\n}\n\nfunction d3_lab_hcl(l, a, b) {\n  return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(\n    NaN, NaN, l);\n}\n\nfunction d3_lab_xyz(x) {\n  return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n}\n\nfunction d3_xyz_lab(x) {\n  return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n}\n\nfunction d3_xyz_rgb(r) {\n  return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n}\nd3.rgb = d3_rgb;\n\nfunction d3_rgb(r, g, b) {\n  return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length <\n    2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb,\n      d3_hsl_rgb) : new d3_rgb(r, g, b);\n}\n\nfunction d3_rgbNumber(value) {\n  return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n}\n\nfunction d3_rgbString(value) {\n  return d3_rgbNumber(value) + \"\";\n}\nvar d3_rgbPrototype = d3_rgb.prototype = new d3_color();\nd3_rgbPrototype.brighter = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  var r = this.r,\n    g = this.g,\n    b = this.b,\n    i = 30;\n  if (!r && !g && !b) return new d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n};\nd3_rgbPrototype.darker = function(k) {\n  k = Math.pow(.7, arguments.length ? k : 1);\n  return new d3_rgb(k * this.r, k * this.g, k * this.b);\n};\nd3_rgbPrototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\nd3_rgbPrototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0,\n    g = 0,\n    b = 0,\n    m1, m2, color;\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n      case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(\n            m2[2]));\n        }\n    }\n  }\n  if (color = d3_rgb_names.get(format.toLowerCase())) {\n    return rgb(color.r, color.g, color.b);\n  }\n  if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n    if (format.length === 4) {\n      r = (color & 3840) >> 4;\n      r = r >> 4 | r;\n      g = color & 240;\n      g = g >> 4 | g;\n      b = color & 15;\n      b = b << 4 | b;\n    } else if (format.length === 7) {\n      r = (color & 16711680) >> 16;\n      g = (color & 65280) >> 8;\n      b = color & 255;\n    }\n  }\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n    max = Math.max(r, g, b),\n    d = max - min,\n    h, s, l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    h = NaN;\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_lab(r, g, b) {\n  r = d3_rgb_xyz(r);\n  g = d3_rgb_xyz(g);\n  b = d3_rgb_xyz(b);\n  var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),\n    y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),\n    z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n  return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n}\n\nfunction d3_rgb_xyz(r) {\n  return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n}\n\nfunction d3_rgb_parseNumber(c) {\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\nvar d3_rgb_names = d3.map({\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n});\nd3_rgb_names.forEach(function(key, value) {\n  d3_rgb_names.set(key, d3_rgbNumber(value));\n});\n/* jshint ignore:end */\n","'use strict';\n\nvar d3 = require('./color');\n\nmodule.exports = function (a, b) {\n  a = d3.lab(a);\n  b = d3.lab(b);\n  var al = a.l,\n      aa = a.a,\n      ab = a.b,\n      bl = b.l - al,\n      ba = b.a - aa,\n      bb = b.b - ab;\n  return function(t) {\n    return d3.lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + '';\n  };\n};","'use strict';\n/* jshint ignore:start */\nvar d3_class = require('./class');\n\nmodule.exports = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n/* jshint ignore:end */","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('../lib/colorbrewer/colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        name: {\n          type: 'string'\n        },\n        aggregate: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n\n    // color\n    c10palette: {\n      type: 'string',\n      default: 'category10',\n      enum: [\n        // Tableau\n        'category10', 'category10k',\n        // Color Brewer\n        'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n      ]\n    },\n    c20palette: {\n      type: 'string',\n      default: 'category20',\n      enum: ['category20', 'category20b', 'category20c']\n    },\n    ordinalPalette: {\n      type: 'string',\n      default: 'BuGn',\n      enum: util.keys(colorbrewer)\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n"],"sourceRoot":"/source/"}